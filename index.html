<!DOCTYPE html>
<html lang="ku" dir="rtl">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title id="main-title">ÛŒØ§Ø±ÛŒØ§ Ø¯Ø±ÙˆÚ©Û•Ø±ÛŒ (Imposter)</title>
 <script src="https://cdn.tailwindcss.com"></script>
 
 <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
 <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
 <script>
     tailwind.config = {
         theme: {
             extend: {
                 colors: {
                     'primary': '#facc15',
                     'secondary': '#6366f1',
                     'dark-bg': '#1e293b',
                     'dark-card': '#334155',
                     'input-bg': '#475569',
                 },
                 fontFamily: {
                     'kurdish': ['Scheherazade New', 'sans-serif'],
                 }
             }
         }
     }
 </script>
 <style>
     @import url('https://fonts.googleapis.com/css2?family=Scheherazade+New:wght@400;700&display=swap');

     body {
         background-color: #0f172a;
         background-image: radial-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), radial-gradient(rgba(255,255,255,0.05) 1px, transparent 1px);
         background-size: 40px 40px;
         background-position: 0 0, 20px 20px;
         display: flex;
         justify-content: center;
         align-items: center;
         min-height: 100vh;
         padding: 20px;
         font-family: 'kurdish';
     }

     /* --- NEW: Online Counter CSS --- */
     #online-counter {
        position: fixed;
        top: 15px;
        right: 20px; /* Positioned on the right for RTL */
        font-size: 0.5rem;
        font-weight: 700;
        z-index: 1000;
        background-color: rgba(30, 41, 59, 0.7); /* dark-bg with some transparency */
        padding: 5px 10px;
        border-radius: 0.5rem;
        color: #34d399; /* Green text */
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        /* Flex for alignment */
        display: flex; 
        align-items: center;
        white-space: nowrap;
     }
     /* If the direction is LTR, you might want to adjust this to left: 20px; */

     .card {
         background-color: var(--dark-card);
         border-radius: 1.5rem;
         padding: 2.5rem 1.5rem;
         box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
         max-width: 420px;
         width: 100%;
         margin-top: 20px;
         margin-bottom: 20px;
     }

     .title-bar {
         border-bottom: 2px solid rgba(255, 255, 255, 0.1);
         padding-bottom: 0.75rem;
         margin-bottom: 1.5rem;
     }

     input[type="number"], input[type="text"], .input-text-area {
         background-color: var(--input-bg);
         color: #f8fafc;
         border: 1px solid #475569;
         border-radius: 0.5rem;
         padding: 0.5rem 0.75rem;
         width: 100%;
         margin-bottom: 0.75rem;
         text-align: right;
     }

     .primary-btn {
         background: linear-gradient(145deg, #facc15, #eab308);
         color: #1e293b;
         font-weight: 700;
         padding: 0.75rem 1.5rem;
         border-radius: 0.75rem;
         box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(0, 0, 0, 0.15);
         transition: all 0.2s;
         width: 100%;
     }

     .primary-btn:hover {
         opacity: 0.9;
         transform: translateY(-1px);
         box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.2);
     }
     
     .secondary-btn {
        background: linear-gradient(145deg, #6366f1, #4f46e5);
        color: white;
        font-weight: 700;
        padding: 0.75rem 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(0, 0, 0, 0.15);
        transition: all 0.2s;
        width: 100%;
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
     }

     .secondary-btn:hover {
         opacity: 0.9;
         transform: translateY(-1px);
         box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.2);
     }
     
     .back-btn {
         background-color: transparent;
         border: 2px solid #94a3b8;
         color: #94a3b8;
         font-weight: 500;
         padding: 0.5rem 1rem;
         border-radius: 0.5rem;
         transition: all 0.2s;
         width: 100%;
         margin-top: 1rem;
     }
     .back-btn:hover {
        background-color: #334155;
        color: #f8fafc;
     }
     
     .lobby-player-item {
         display: flex;
         justify-content: space-between;
         align-items: center;
         background-color: #475569;
         padding: 0.5rem 1rem;
         border-radius: 0.5rem;
         margin-bottom: 0.5rem;
         color: #f8fafc;
         font-size: 1rem;
     }
     .lobby-player-item.creator {
         border: 2px solid #facc15;
     }
     .lobby-player-item .status {
         font-size: 0.875rem;
         color: #94a3b8;
     }
     .lobby-player-item .status.ready {
         color: #34d399;
         font-weight: 700;
     }
     
     .lobby-player-item .remove-btn {
         background-color: #f87171;
         color: white;
         border: none;
         border-radius: 0.25rem;
         padding: 0.25rem 0.5rem;
         cursor: pointer;
         font-size: 0.75rem;
         font-weight: 700;
         transition: background-color 0.2s;
         margin-right: 0.5rem;
     }
     .lobby-player-item .remove-btn:hover {
         background-color: #ef4444;
     }


     .player-card {
         background-color: #475569;
         border: 1px solid #64748b;
         padding: 20px;
         border-radius: 1rem;
         margin-top: 1.5rem;
         text-align: center;
         box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
         transition: all 0.3s;
     }
   
     .player-card:hover {
         transform: scale(1.02);
     }

     .word-civilian {
         color: #34d399;
     }
     .word-imposter {
         color: #f87171;
     }

     .role-text {
         font-size: 1.5rem;
         font-weight: 700;
         color: var(--primary);
         margin-bottom: 10px;
     }
     .role-text-simplified {
         font-size: 2rem;
         font-weight: 700;
         margin-bottom: 0;
     }

     .word-text {
         font-size: 1.25rem;
         color: #f8fafc;
     }
   
     .footer-text {
         margin-top: 2rem;
         text-align: center;
         font-size: 0.8rem;
         color: #94a3b8;
     }
   
     .footer-text a {
         color: var(--primary);
         text-decoration: none;
         margin-right: 5px;
         margin-left: 5px;
     }
     .footer-text a:hover {
         text-decoration: underline;
     }

     #custom-modal {
         position: fixed;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         background-color: rgba(0, 0, 0, 0.7);
         display: flex;
         justify-content: center;
         align-items: center;
         z-index: 1000;
         opacity: 0;
         visibility: hidden;
         transition: opacity 0.3s, visibility 0.3s;
         overflow-y: auto;
     }
     #custom-modal.show {
         opacity: 1;
         visibility: visible;
     }
     .modal-content {
         background-color: var(--dark-card);
         margin: 5% auto; 
         padding: 2rem;
         border-radius: 1rem;
         max-width: 350px;
         width: 90%;
         color: #f8fafc;
         text-align: center;
         box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
         transform: translateY(-50px);
         transition: transform 0.3s;
         max-height: 90vh;
         overflow-y: auto;
         position: relative;
     }
     #custom-modal.show .modal-content {
         transform: translateY(0);
     }
     .modal-title {
         font-size: 1.5rem;
         font-weight: 700;
         color: #facc15;
         margin-bottom: 0.75rem;
     }
     .imposter-popup .modal-title {
        color: #f87171;
        font-size: 2rem;
     }
     .imposter-popup .modal-message {
        font-size: 1.5rem;
        font-weight: bold;
        color: #facc15;
     }
     .modal-message {
         margin-bottom: 1.5rem;
         font-size: 1rem;
         text-align: right;
     }
     .modal-message strong {
         color: #facc15;
     }
     
     .modal-close-btn {
        position: absolute;
        top: 10px;
        right: 10px; 
        font-size: 1.5rem;
        background: none;
        border: none;
        color: #f8fafc;
        cursor: pointer;
        line-height: 1;
        padding: 5px;
     }
     .rtl .modal-close-btn {
        right: 10px;
        left: auto;
     }
     
     #room-code-display {
         font-family: 'Roboto', monospace;
         font-size: 2.5rem;
         font-weight: 900;
         color: #facc15;
         letter-spacing: 0.2rem;
         margin: 1rem 0;
         text-align: center;
         user-select: all;
     }
     #room-code-label {
         color: #94a3b8;
         font-weight: 700;
         font-size: 1.1rem;
     }
     
     .share-button {
         position: fixed;
         bottom: 20px;
         right: 20px;
         background-color: var(--secondary);
         color: white;
         border: none;
         border-radius: 50%;
         width: 50px;
         height: 50px;
         display: flex;
         align-items: center;
         justify-content: center;
         cursor: pointer;
         box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
         z-index: 1000;
         transition: background-color 0.2s, transform 0.2s;
     }
     .share-button:hover {
         background-color: #4f46e5;
         transform: scale(1.05);
     }

     .help-button {
         position: fixed;
         bottom: 20px;
         right: 90px;
         background-color: #34d399;
         color: #1e293b;
         border: none;
         border-radius: 50%;
         width: 50px;
         height: 50px;
         font-size: 1.5rem;
         font-weight: bold;
         display: flex;
         align-items: center;
         justify-content: center;
         cursor: pointer;
         box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
         z-index: 1000;
         transition: background-color 0.2s, transform 0.2s;
     }
     .help-button:hover {
         background-color: #10b981;
         transform: scale(1.05);
     }
     
     /* --- CHAT CSS --- */
     #chat-button {
         position: fixed;
         bottom: 20px;
         right: 160px; 
         background-color: #eab308;
         color: #1e293b;
         border: none;
         border-radius: 50%;
         width: 50px;
         height: 50px;
         display: flex; /* Ú¯Û†Ú•Ø§Ù†Ú©Ø§Ø±ÛŒ: Ù‡Û•Ù…ÛŒØ´Û• ÙˆÛ•Ú© flex Ø¯Û•Ø±Ø¨Ú©Û•ÙˆÛØª (Ø¦Û•Ú¯Û•Ø± Ù„Û• Ø¯Û†Ø®ÛŒ Ú˜ÙˆÙˆØ±Ø¯Ø§ Ø¨ÛŒÙ†) */
         align-items: center;
         justify-content: center;
         cursor: pointer;
         box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
         z-index: 1000;
         transition: background-color 0.2s, transform 0.2s;
     }
     #chat-button:hover {
         background-color: #facc15;
         transform: scale(1.05);
     }
     #unread-count {
         position: absolute;
         top: -5px;
         right: -5px;
         background-color: #ef4444; 
         color: white;
         border-radius: 50%;
         padding: 0 5px;
         font-size: 0.75rem;
         min-width: 18px;
         text-align: center;
         line-height: 18px;
         font-weight: bold;
         display: none; 
     }
     
     #chat-modal {
         position: fixed;
         bottom: 80px;
         right: 15px;
         width: 300px;
         height: 400px;
         background-color: var(--dark-card);
         border-radius: 1rem;
         box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
         z-index: 999;
         display: flex;
         flex-direction: column;
         opacity: 0;
         visibility: hidden;
         transform: translateY(20px);
         transition: opacity 0.3s, visibility 0.3s, transform 0.3s;
         color: #f8fafc;
     }
     #chat-modal.show {
         opacity: 1;
         visibility: visible;
         transform: translateY(0);
     }
     
     .chat-header {
         display: flex;
         justify-content: space-between;
         align-items: center;
         padding: 0.75rem 1rem;
         border-bottom: 1px solid #475569;
     }
     .chat-header h3 {
         font-size: 1.25rem;
         font-weight: 700;
         color: var(--primary);
     }
     .chat-close-btn {
        background: none;
        border: none;
        color: #f8fafc;
        cursor: pointer;
        font-size: 1.5rem;
     }

     #messages-container {
         flex-grow: 1;
         padding: 1rem;
         overflow-y: auto;
         display: flex;
         flex-direction: column-reverse; 
     }
     
     /* --- NEW: Unique Player Colors and White Message Text --- */
     .message-item {
         margin-bottom: 0.5rem;
         line-height: 1.4;
     }
     .message-item .sender-name {
         font-weight: 700;
         margin-left: 0.5rem; 
     }
     .message-item .message-text {
         color: #f8fafc; 
         display: block;
         word-wrap: break-word;
     }
     /* Unique colors for players (12 colors) */
     .player-color-0 { color: #f87171; } /* Red */
     .player-color-1 { color: #34d399; } /* Emerald */
     .player-color-2 { color: #60a5fa; } /* Blue */
     .player-color-3 { color: #facc15; } /* Yellow */
     .player-color-4 { color: #a78bfa; } /* Violet */
     .player-color-5 { color: #f472b6; } /* Pink */
     .player-color-6 { color: #4ade80; } /* Light Green */
     .player-color-7 { color: #fb923c; } /* Orange */
     .player-color-8 { color: #2dd4bf; } /* Teal */
     .player-color-9 { color: #e879f9; } /* Fuchsia */
     .player-color-10 { color: #94a3b8; } /* Slate */
     .player-color-11 { color: #fca5a5; } /* Light Red */
     /* --- END NEW --- */


     .chat-input-area {
         display: flex;
         padding: 0.5rem 1rem;
         border-top: 1px solid #475569;
     }
     #chat-input {
         flex-grow: 1;
         margin-bottom: 0;
         margin-right: 0.5rem;
         background-color: #475569;
     }
     .send-btn {
         background-color: var(--primary);
         color: #1e293b;
         border-radius: 0.5rem;
         padding: 0.5rem 1rem;
         font-weight: 700;
         cursor: pointer;
         transition: opacity 0.2s;
     }
     .send-btn:hover {
         opacity: 0.9;
     }
 </style>
</head>
<body class="rtl" style="--dark-card: #334155; --input-bg: #475569; --primary: #facc15; --secondary: #6366f1;">

    <div id="online-counter">Online (0)</div>
    <div id="game-container" class="card">
     </div>

 <div id="custom-modal">
     <div class="modal-content" id="modal-inner">
         </div>
 </div>
 
 <div id="chat-modal">
    <div class="chat-header">
        <h3>Ú¯ÙØªÙˆÚ¯Û†</h3>
        <button class="chat-close-btn" onclick="toggleChatModal()">Ã—</button>
    </div>
    <div id="messages-container">
        </div>
    <div class="chat-input-area">
        <input type="text" id="chat-input" placeholder="Ù†Ø§Ù…Ø§ Ø®Ùˆ Ø¨Ù†Ú¤ÛŒØ³Û•..." 
               onfocus="isInputFocused = true" 
               onblur="isInputFocused = false"
               onkeyup="if(event.keyCode === 13) sendMessage()">
        <button class="send-btn" onclick="sendMessage()">Ù‡Ù†Ø§Ø±ØªÙ†</button>
    </div>
 </div>

 <button id="shareButton" class="share-button" onclick="shareGameLink()">
     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-share-2"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>
 </button>

 <button id="helpButton" class="help-button" onclick="showHelpModal()">
    ?
 </button>
 
 <button id="chat-button" onclick="toggleChatModal()" style="display: none;">
     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
     <span id="unread-count"></span>
 </button>


 <script>
    const firebaseConfig = {
        apiKey: "YOUR_API_KEY", 
        authDomain: "kigbynaseh.firebaseapp.com",
        databaseURL: "https://kigbynaseh-default-rtdb.firebaseio.com",
        projectId: "kigbynaseh",
        storageBucket: "kigbynaseh.appspot.com",
        messagingSenderId: "YOUR_SENDER_ID",
        appId: "YOUR_APP_ID"
    };
    
    // --- CHAT FIREBASE CONFIGURATION ---
    const chatFirebaseConfig = {
        databaseURL: "https://kigmessages-8e8dd-default-rtdb.firebaseio.com/" // The provided database link
    };
    
    let chatApp;
    let chatDatabase;
    let chatRef;
    let lastKnownMessageCount = 0;

    const modal = document.getElementById('custom-modal');
    const modalInner = document.getElementById('modal-inner');
    const shareButton = document.getElementById('shareButton');
    const helpButton = document.getElementById('helpButton');
    const chatButton = document.getElementById('chat-button');
    const chatModal = document.getElementById('chat-modal');
    const unreadCountSpan = document.getElementById('unread-count');
    const messagesContainer = document.getElementById('messages-container');
    const chatInput = document.getElementById('chat-input');
    // --- NEW: Online Counter Element ---
    const onlineCounter = document.getElementById('online-counter');


    let database;
    let roomRef;
    let myPlayerId = null;
    let myPlayerName = ''; 
    let playerColorMap = {}; 
    let presenceRef; // Reference for the online counter
    let myConnectionRef; // Reference for the user's connection status

    const WORDS_KU = [
        "Ù†ÙˆÚ˜Ø¯Ø§Ø±", "Ù…Ø§Ù…Û†Ø³ØªØ§", "Ø¦Û•Ù†Ø¯Ø§Ø²ÛŒØ§Ø±", "ØªÛ•Ù„Û•Ú¤Ø²ÛŒÙˆÙ†", "Ø´Û†ÙÛØ±", "Ù¾Ø§ÛŒØ³Ú©Ù„", "Ø³Ø§Ø±Ø¯Û•Ù…Û•Ù†ÛŒ", "Ø®Ø§Ù„Ø®Ø§Ù„ÙˆÚ©",
        "Ù¾Ø§Ø±Û•", "ÙˆÛÙ†Û•Ú©ÛØ´", "Ù¾Ø§Ù¾ÙˆØ±", "Ù†Ø§Ù†Ù¾ÛÚ˜", "Ø¬Ú¯Ø§Ø±Û•", "ÙˆÛ•Ø±Ø²Ø´Ú¤Ø§Ù†", "Ø¨Û•Ù†ÛŒØ´Øª", "Ù¾Û†Ù„ÛŒØ³",
        "Ø³Û•Ø±Ø¨Ø§Ø²", "Ø¦Ø§Ú¯Ø±Ú©ÙˆÚ˜ÛÙ†Û•Ø±", "Ø¨Ø§Ø²Ø±Ú¯Ø§Ù†", "Ú•Û†Ú˜Ù†Ø§Ù…Û•Ù†Ú¤ÛŒØ³", "Ø¬ÙˆÙˆØªÛŒØ§Ø±", "Ù¾Ø§Ø³Û•ÙˆØ§Ù†", "Ù‚Û•Ø´Û•", "Ú©Ø§ØªÚ˜Ù…ÛØ±", "Ø´Ú¤Ø§Ù†", 
        "Ø³Û•", "Ù¾Ø´ÛŒÚ©", "Ú©Û•Ùˆ", "Ù‡Ø±Ú†", "Ú¯ÙˆØ±Ú¯", "Ø®Û•Ø²Ø§Ù„", "Ø±ÛŒÚ¤ÛŒ", "Ø´ÛØ±", "Ù†Û•Ù‡Û•Ù†Ú¯", "Ù‡Û•Ø³Ù¾","Ù¾ÛŒØªØ²Ø§" , "Ø´Û•Ù…Ø´Û•Ù…Û•Ú©ÙˆØ±",
        "Ø³Ú¤Û†Ø±Û•", "ÙÛŒÙ„", "Ù…Û•ÛŒÙ…ÛŒÙ†Ú©", "Ú©Û•Ù†Ø¬Ø§Ù„", "Ú©Û•Ø±", "Ù…ÙˆÙ…ÛŒØ§", "Ù‚Û•Ù„Û•Ú•Û•Ø´Ú©", "Ø¨Û•Ù„Ø§ØªÛŒÙ†Ú©", "Ù…Ø±ÛŒØ´Ú©", "Ù‚Ø§Ø²", "Ù…Û•Ø±",
        "Ù…Ø§Ø±", "Ú©Ø±Ù…", "Ú¯ÙˆØ³ØªÛŒÙ„", "Ú©ÛŒØ³Û•Ù„Û•", "ØªÛŒÙ…Ø³Ø§Ø­", "Ø¨Û•Ù‚", "Ù…Ø§Ø³ÛŒ", "Ù‚Ø±Ø´", "Ø¦Û•Ø®ØªÛ•Ø¨ÙˆØª", "Ø²Û•Ø±Ø§ÙÛ•", "Ø¯Û†Ù„ÙÛŒÙ†", 
        "ÙØ±Ú†Û Ø¯Ø¯Ø§Ù†Ø§Ù†", "Ù…ÛØ±ÛŒ", "Ù…ÛØ´", "Ú©Ú¤Ø±ÛŒØ´Ú©", "Ù‚ÙˆÙ†Ø¯Ú©", "Ø¯ÙˆÛŒÙ¾Ø´Ú©", "Ù…Ø´Ú©", "Ø´ÛØ±", "Ù¾ÚµÙ†Ú¯", "Ú©ÙˆØªØ±",
        "Ø¯Ø§Ø±", "Ú¯ÙˆÚµ", "Ù†Ø§Ù†", "ÙÛŒÙ‚ÛŒ", "Ú©Û•Ø³Ú©Ø§ØªÛŒ", "Ø´Ø§Ù‡", "Ø¦ÛŒÙ…Ø§Ù…", "Ù¾Û", "Ø¯Û•Ø³Øª", "Ø³Ù…Ø¨ÛÙ„", "Ø³ØªÛØ±", 
        "Ø¬ÙˆØ¨Ø±Ú©", "Ø¨Û•Ù„Ú¯", "ØªÛ•Ù…Ø§ØªÛ•", "Ø®ÛŒØ§Ø±", "Ù¾ÛŒÚ¤Ø§Ø²", "Ø³ÛŒØ±", "Ú©Ú¤Ø§Ø±Ú©", "Ù…Û†Ø²", "ÙØ±Ù†ÛŒ", "ØªÛŒ", "Ú¯Ú˜ÙˆÚ¯ÛŒØ§", "Ø¯Û•Ø®Ù„", "Ú¯Û•Ù†Ù…Û•Ø´Ø§Ù…ÛŒ",
        "Ù¾Ù„Û•ÛŒ Ø³ØªÛ•ÛŒØ´Ù†", "Ø²Ø§Ù†Ø§", "Ú©Ø±ØªÙˆÙ¾", "Ú†Ø§", "Ù‚Û•Ù‡ÙˆÛ•", "Ø´ÛŒØ±", "Ù‡Ù†Ú¯Ú¤ÛŒÙ†", "Ø²Û•ÛŒØªÙˆÙˆÙ†", "Ø¨ÛØ±Ú¯Û•Ø±", "Ø¯Ø¯Ø§Ù†", "Ø¨ÙŠØ¨Ù‡ Ø±","ÙƒÛÚ©","Ø±ÛŒØ¨Ø§Ø±", "Ø³Ø±ÙˆØ´Øª", 
        "Ú†ÛŒØ§", "Ø¯Ø§Ø±Ø³ØªØ§Ù†", "Ø¯Û•Ø±ÛŒØ§", "Ú¯ÙˆÙ†Ø¯", "Ø¨Ø§Ú˜ÛØ±", "Ù…Ø§Úµ", "Ù‚ÙˆØªØ§Ø¨Ø®Ø§Ù†Û•", "Ø²Ø§Ù†Ú©Û†", "Ú©Ø§Ø±Ú¯Û•", "Ù‚Û•Ø³Ù¾", "Ø¨ÛŒØ§Ø¨Ø§Ù†",
        "Ø³ÛŒÙ†Û•Ù…Ø§", "Ù…Ø²Ú¯Û•ÙØª", "Ø­Û•ÙˆØ´", "Ù‚Ù„ÛÙ†Û•", "Ù‚Û•ÚµØ§", "Ø±ÛÚ©", "ØªÛŒØªÚ©", "ØªØ§ØªÙˆ", "ÙÛŒÙ„", "Ú©Ø§Ù†ÛŒ",
        "ØªØ±ÙˆÙ…Ø¨ÛÙ„","Ø³ÛŒÙ†ÛŒÚ©","Ø¯Û•Ø±Û•Ø¬Û•", "ÙÚ•Û†Ú©Û•", "Ø´Û•Ù…Û•Ù†Ø¯Û•ÙØ±", "Ù¾Ø§Ø³Ú©ÛŒÙ„", "Ú˜Ú¤Ú˜ÛŒ", "Ø±ÙˆÚ˜", "Ù‡Û•Ú¤Ø§Ù„", "Ø¬ÛŒØ±Ø§Ù†", "Ø­ÛØ´ØªØ±",
        "Ú©Û•Ù…Ù¾", "Ù†ÛŒÙ†ÙˆÚ©", "Ø¨Ø±ÛŒØ³ÛŒ", "Ù‚Û•Ø¨Ø±", "Ú¯Û•Ø±Ø§Ø¬", "Ø¯Û•Ø³ØªÙ…Ø§Ù„", "Ø¯ÙˆÚ©Ø§Ù†", "Ù‚Ø§ÙˆÛ•Ø®Ø§Ù†Û•", "Ú©ØªÛØ¨ÙØ±Û†Ø´",
        "Ù¾ÛÙ„ÛÙ† Ø¯Û•Ø±ÛŒØ§ÛŒÛ", "Ú©Ø±ÛŒØ³ØªÛŒØ§Ù†Ùˆ", "ÙØ§Ù†ÙˆØ³", "Ú¯ÙˆØ±Û•", "Ø¨Ø±Ú©Ø§Ù†", "Ø®Û•Ø²ÛŒÙ†Û•", "Ø¯Û•Ø±Ú¯Û•Ù‡", "Ù¾Û•Ù†Ø¬Û•Ø±Û•", "Ø¨Ø§Ù„ÛŒÙÚ©",
        "Ù¾Û•Ø±Ø³ÛŒÚ¤", "Ø¦Ø§Ú¤", "Ø¹Û•Ú¤Ø±", "Ø¨Ø§Ø±Ø§Ù†", "Ø¨Û•ÙØ±", "Ø¨Û•ØªÛ•Ù†ÛŒ", "Ù‡Û•ÛŒÚ¤", "Ø²Û•ÛŒØª", "Ú©ØªÛØ¨", "Ù‚Û•ÚµÛ•Ù…", "Ù„Ø§Ù¾Û•Ú•",
        "Ù…Û†Ø¨Ø§ÛŒÙ„", "Ú©Û†Ù…Ù¾ÛŒÙˆØªÛ•Ø±", "Ù¾ÛŒØ§Ù†Ùˆ", "Ø¹Û•Ù‚Ù„", "Ú†ÛŒØ±ÙˆÚ©", "Ø¨ÛŒÚ©", "Ù†ÛØ±Ú¯Ø²", "Ù†Û•ÙØª", "ÛŒØ§Ø±ÛŒ", "ØªÛ•Ù¾Ø§ Ø¯Û•Ø³ØªÛŒ", "Ø²Ø§Ú¤Ø§",
        "Ù‡ÛÙ„Ú©", "Ú¯Ø§Ø²", "Ù¾Ø§Ù†Ø²ÛŒÙ†", "Ú©Û•Ù‡Ø±Û•Ø¨", "Ø³ÙˆÙ¾Û•", "Ù†Û•Ø¹Ø§Ù„", "Ø¯Ø§Ø¯Ú¯Û•Ù‡", "Ø¯Ø±ÙˆÚ©Û•Ø±", "Ø¯Ø²ÛŒÚ©Û•Ø±", "Ø®Û•Ø³ÛŒ", 
        "Ø®Û•Ø²ÛŒØ±", "Ù„Û•ÛŒÙ…ÙˆÙ†", "Ù¾Ø±ØªÛ•Ù‚Ø§Ù„", "Ù‡Ú˜ÛŒØ±", "Ú©Ø§Ø³", "ÙÙ„Ø§ÙÙ„", "ÙˆØ§Ù‡ÛØ±", "Ø²Ø§Ø±ÙˆÚ©", "Ù¾ÛŒØ±",
        "Ù…Ø±Û†Ú¤", "Ú©Ù„Ø§Ú¤", "Ú¯ÙˆÙ„Ø§Ú¤", "Ø³ÛÚ¤", "Ø¨Ø§Ù…ÛŒ", "Ø¨Û•Ù„Û•Ù…", "ØªÙˆØ±Û•", "Ú¯Ù„ÛØ´", "Ú©ÛØ±Ú©", "Ø²ÛØ±", 
        "Ø¨Ù„Ø¨Ù„", "Ø¦Ø§Ø±", "Ø´Û•Ú©Ø±ÙˆÚ©", "Ø®ÙˆÛ", "Ø³Ø¨Øº", "Ù…ÙˆÙ…", "Ø®ÙˆÛŒÙ†", "Ø³Û•ØªÛ•Ù„Ø§ÛŒØª", "Ø¯Úµ", "Ø¬Ø²Ø¯Ø§Ù†", "Ø¬Û•Ú˜Ù†", "Ú©Ù„ÛŒÙ„", "Ù‚ÙˆÙÙ„", 
        "Ø­Û•Ø¯ÛŒÙ‚Û•", "Ú†Û•Ø±Ù…", "Ù…ÛŒ", "Ù¾ÛÙ„Ø§Ú¤", "Ú©Ù„Ùˆ", "Ù…Ø§ØªÛ†Ø±", "Ù‚Û•Ù„Ø§Ø¨Ù‡", "ÙÛŒØ´Û•Ú©", "Ø¨Û†Ù…Ø¨Û•", "ØªØ²Ø¨ÛŒ", "Ù…ÙˆØ¨Û•Ø±ÛŒØ¯Û•", 
        "ØªÛ•Ø®Øª", "Ø³Û•Ù„Ø§Ø¬Û•", "Ø³Ù¾Ù„ÛØª", "Ø³ÛŒØ³Ø±Ú©", "Ø¯Û•Ø¨Ø§Ù†Ú†Û•", "Ù‚Ø§ØªÛ•", "Ø´Ù‚Û•", "ØªØ±ÛÙ„Û•", "Ø¬ÛÙ„ÛŒ", "Ú¯ÙˆÙ„",
        "Ù‚Û•Ù„Û•ÙÙ„", "Ù…Û•Ù„Û•Ú¤Ø§Ù†Ú¯Û•Ù‡", "Ù‡ÙˆØªÛÙ„", "Ø´ÛŒØ±", "Ø¦Ø§Ø´", "Ø¯ÙˆØ´Û•", "Ù…ÙˆÙ„Û•ØªØ§ Ø´ÙˆÙÛØ±ÛŒÛ", "Ú©Ø§Ø¨ÛŒÙ†Û•", "Ø´Ú¤Ø§Ù†", "Ú©Û•Ù‡Ø±Û•Ø¨", "Ø±ÛÚ¤Ø§Ø²", "Ú©Û•Ø±Û•ÙØ³"
    ];


    let lang = 'ku';
    let playerCount = 4;
    let imposterCount = 1;
    let playerNames = [];
    let gameActive = false;
    let roles = [];
    let secretWord = '';
    let imposterHintWord = '';

    let isRoomMode = false;
    let currentRoomCode = null;
    let isRoomCreator = false;
    let isGameStartedInRoom = false;
    let isInputFocused = false; 

    let timerInterval;
    let timeLeft;


    const getWordList = () => WORDS_KU;

    const T = (key) => {
        const translations = {
            ku: {
                appName: "ÛŒØ§Ø±ÛŒØ§ Ø¯Ø±ÙˆÚ©Û•Ø±ÛŒ", imposter: "Ø¯Ø±ÙˆÚ©Û•Ø±", civilian: "Ù¾Ø§Ø±Ø§Ø³ØªÛŒ", playerCount: "Ú˜Ù…Ø§Ø±Ø§ ÛŒØ§Ø±ÛŒÚ©Û•Ø±Ø§Ù† (3-12):", imposterCount: "Ú˜Ù…Ø§Ø±Ø§ Ø¯Ø±ÙˆÚ©Û•Ø±Ø§Ù† (1-2):", start: "Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ù†Ø§ ÛŒØ§Ø±ÛŒÛ", playerName: "Ù†Ø§Ú¤", showRole: "Ú•Û†Ù„Û Ø®Ùˆ Ø¨Ø¨ÛŒÙ†Û•", yourRole: "Ú•Û†Ù„Û ØªÛ•:", theWord: "Ù¾Û•ÛŒÚ¤Ø§ Ù†Ù‡ÛÙ†ÛŒ:", madeBy: "Made By Naseh M. Zebari", turn: "Ø³Ø±Ø§ ÛŒØ§Ø±ÛŒÚ©Û•Ø±ÛŒ", close: "Ú¯Ø±ØªÙ†", reset: "Ø¯ÙˆÙˆØ¨Ø§Ø±Û• Ø¯Û•Ø³Ù¾ÛØ¨Ú©Û•Ú¤Û•", wordWas: " Ù¾Û•ÛŒÚ¤Ø§ Ù†Ù‡ÛÙ†ÛŒ :", selectWord: "  Ù¾Û•Ú¤Ø§ Ù†Ù‡ÛÙ†ÛŒ Ù‡Û•Ù„Ø¨Ú˜ÛØ±Û• !", validationTitle: "Ø¦Ø§Ú¯Û•Ù‡Ø¯Ø§Ø±ÛŒ", nameRequired: " Ù†Ø§Ú¤Û Ù‡Û•Ù…ÛŒ ÛŒØ§Ø±ÛŒÚ©Û•Ø±Ø§Ù† Ø¨Ù†Ú¤ÛŒØ³Û•.", notEnoughPlayers: "Ú˜Ù…Ø§Ø±Ø§ ÛŒØ§Ø±ÛŒÚ©Û•Ø±Ø§Ù† ÛŒØ§ Ú©ÛÙ…Û•ØŒ Ø¯Ú¤ÛØª Ø¨ Ú©ÛÙ…ÛŒ Ù£ ÛŒØ§Ø±ÛŒÚ©Û•Ø± Ø¨Ù†.", impostersWere: " Ø¯Ø±ÙˆÚ©Û•Ø± Ù¾ÛÚ©Ù‡Ø§ØªØ¨ÛŒÙ† Ú˜:", justImposter: "ØªÛ† Ø¯Ø±ÙˆÚ©Û•Ø±ÛŒ ğŸ¤«!", imposterHintLabel: "Ù¾Û•ÛŒÚ¤ :", startDiscussion: "Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ø¯Ù†Ø§ Ú¯ÙØªÙˆÚ¯Û†ÛŒÛ", discussionTime: "Ø¯Û•Ù…Û Ú¯ÙØªÙˆÚ¯Û†ÛŒÛ :", timesUp: " Ø¯Û•Ù… Ø¨ Ø¯ÙˆÙ…Ø§Ù‡ÛŒÚ© Ù‡Ø§Øª !", imposterWas: "    Ø¯Ø±ÙˆÚ©Û•Ø± :", shareLink: "   Ù„ÛŒÙ†Ú©Û ÛŒØ§Ø±ÛŒÛ Ø¨Ùˆ Ù‡Û•Ú¤Ø§Ù„ÛÙ† Ø®Ùˆ Ù¾Ù†ÛØ±Û• !", and: "Ùˆ", howToPlayTitle: "Ø¯Û Ú†Û•ÙˆØ§ ÛŒØ§Ø±ÛŒÛ Ú©Û•ÛŒ: ÛŒØ§Ø±ÛŒØ§ Ø¯Ø±ÙˆÚ©Û•Ø±ÛŒ", howToPlayBody: `Ø¦Ø§Ø±Ù…Ø§Ù†Ø¬ Ø¦Û•ÙˆÛ• Ú©Ùˆ Ø¨Ùˆ Ù‡Û•Ù…ÛŒØ§Ù† Ø±ÙˆÙ‡Ù† Ø¨Ú©Û•ÛŒ Ú©Ùˆ ØªÙˆ Ù¾Û•ÛŒÚ¤Ø§ Ù†Ù‡ÛÙ†ÛŒ Ø¯Ø²Ø§Ù†ÛŒ- ÛŒØ§Ù†Ú˜ÛŒ ÙˆÛŒ Ú©Û•Ø³ÛŒ Ø¯ÛŒØ§Ø± Ø¨Ú©Û•ÛŒ Ú©Ùˆ Ù¾Û•ÛŒÚ¤Ø§ Ù†Ù‡ÛÙ†ÛŒ Ù†Ø²Ø§Ù†ÛŒØª.<br><br><strong>Ù¡. ğŸ¤« Ø±ÙˆÙ„Û Ø®Ùˆ Ø¨Ø¨ÛŒÙ†Û•  </strong><br>â€¢ Ù…Û†Ø¨Ø§ÛŒÙ„ Ø¯Û Ù„ Ø³Û•Ø± Ù‡Û•Ù…ÛŒ ÛŒØ§Ø±ÛŒÚ©Û•Ø±Ø§Ù† Ø²Ú¤Ø±ÛŒØª Ø¯Ø§ Ú©Ùˆ Ù‡Û•Ø± Ø¦ÛÚ© Ø±ÙˆÙ„Û Ø®Ùˆ Ø¨Ø¨ÛŒÙ†Øª.<br>â€¢ Ø²Û†Ø±ÛŒÙ†Ø§ ÛŒØ§Ø±ÛŒÚ©Û•Ø±Ø§Ù† <strong>  Ù¾Û•ÛŒÚ¤Ø§ Ù†Ù‡ÛÙ†ÛŒ</strong>Ø¯Ø¨ÛŒÙ†Ù† .<br>â€¢  Ø¦ÛÚ© ÛŒØ§Ø±ÛŒÚ©Û•Ø± <strong>"Ù¾Û•ÛŒÚ¤Ø§ ( Ø¯Ø±ÙˆÚ©Û•Ø± )"</strong> Ø¯Ø¨ÛŒÙ†ÛŒØª.<br><br><strong>Ù¢. ğŸ—£ï¸ Ø¦Ø§Ù…Ø§Ú˜Û Ø¨Ø¯Û•</strong><br>â€¢ Ù„ Ø¯Û•ÙˆØ±Û Ø¨Ø§Ø²Ù†Û Ø¯Ø§ Ø¨Ø²Ú¤Ø±Ù†. Ù‡Û•Ø± ÛŒØ§Ø±ÛŒÚ©Û•Ø±Û•Ú© <strong>Ø¦ÛÚ© Ù¾Û•ÛŒÚ¤Û </strong> Ø¨Û† ÙˆÛ•Ø³ÙÚ©Ø±Ù†Ø§ Ù¾Û•ÛŒÚ¤Ø§ Ù†Ù‡ÛÙ†ÛŒ Ø¯Ø¨ÛÚ˜ÛŒØª.<br>â€¢ <strong>Ø¦Û•Ú¯Û•Ø± Ù¾Û•ÛŒÚ¤Û Ø¨Ø²Ø§Ù†ÛŒØª:</strong> Ø¦Ø§Ù…Ø§Ú˜Ø§ ØªÛ• Ø¯Ú¤ÛØª ØªÛØ±Ø§ Ù‡Ù†Ø¯Û Ø¨Ú©Û•Øª Ú©Ùˆ Ø¨ Ø³Û•Ù„Ù…ÛŒÙ†ÛŒØª ØªÙˆ Ù¾Û•ÛŒÚ¤Ø§ Ù†Ù‡ÛÙ†ÛŒ Ø¯Ø²Ø§Ù†ÛŒØŒ Ø¨Û•Ù„Û Ù‡Ù†Ø¯Ø§ Ø¯ÛŒØ§Ø± Ù†Û•Ø¨ÛŒØª Ú©Ùˆ Ø¯Ø±ÙˆÚ©Û•Ø± ÙØ§ÛŒØ¯Û•ÛŒ Ú˜Û Ø¨Ø¨ÛŒÙ†ÛŒØª.<br>â€¢ <strong>Ø¦Û•Ú¯Û•Ø± ØªÙˆ Ø¯Ø±ÙˆÚ©Û•Ø±ÛŒ:</strong>Ø¦Ø§Ù…Ø§Ú˜Û•Ú©Ø§ Ú¯Ø´ØªÛŒ Ø¨ÛÚ˜Û• Ú©Ùˆ ØªÛ• ØªÛÚ©Ù‡Û•Ù„ÛŒ ÛŒØ§Ø±ÛŒÚ©Û•Ø±Ø§Ù† Ø¨Ú©Û•Øª Ùˆ Ø¨Ø´ÛÛŒ Ø®Ùˆ Ú¤Û•Ø´ÛØ±ÛŒ!<br><br><strong>Ù£. ğŸ—³ï¸ Ø¯Û•Ù†Ú¯Ø¯Ø§Ù†</strong><br>â€¢ Ù¾Ø´ØªÛŒ Ú†Û•Ù†Ø¯ Ú¯Û•Ø±Ø§Ù†ØŒ Ø¦Ø§Ù…Ø§Ú˜Û Ø¨Ø¯Û• ÙˆÛŒ Ú©Û•Ø³ÛŒ Ú©Ùˆ ØªÙˆ Ú˜Û Ø¯ÙˆÙˆØ¯Ù„ÛŒ Ú©Ùˆ Ø¦Û•Ùˆ Ø¯Ø±ÙˆÚ©Û•Ø±Û•ØŒ ÛŒØ§Ù†Ú˜ÛŒ Ù‡Û•ÙˆÙ„ Ø¯Ø¯Û•Øª Ø®Ùˆ ØªÛÚ©Ù‡Û•Ù„ÛŒ ÛŒØ§Ø±ÛŒÚ©Û•Ø±Ø§Ù† Ø¨Ú©Û•Øª.<br>â€¢ Ù‡Û•Ù…ÛŒ Ø¯Û Ø¯Û•Ù†Ú¯ÛŒ Ø¯Û•Ù†Û• ÙˆÛŒ Ú©Û•Ø³ÛŒ ÛŒÛ Ú©Ùˆ Ù‡Û•Ø± Ø¦ÛÚ© Ú˜Ù„Ø§ÛŒÛ Ø®ÙˆÚ¤Û• Ú˜Û Ø¯ÙˆÙˆ Ø¯Ù„Û•.<br><br><strong>Ø¯Û Ú†Û•ÙˆØ§ ÛŒØ§Ø±ÛŒÛ Ø¨Û•ÛŒ  ğŸ† :</strong><br><br>â€¢ <strong>Ú©Û•Ø³ÛÙ† Ù¾Ø§Ø±Ø§Ø³ØªÛŒ:</strong><br>-Ø¦Û•Ú¯Û•Ø± Ù¾ÛØ´ Ø¯ÙˆÙ…Ø§Ù‡ÛŒÚ© Ù‡Ø§ØªÙ†Ø§ Ø¯Û•Ù…ÛŒ Ø´ÛŒØ§ Ø¯Ø±ÙˆÚ©Û•Ø±ÛŒ Ø¯ÛŒØ§Ø±Ø¨Ú©Û•Ù†.<br><br>â€¢ <strong>Ø¯Ø±ÙˆÚ©Û•Ø±:</strong><br>-Ø¦Û•Ú¯Û•Ø± Ù¾ØªØ±ÛŒØ§ Ø¯Û•Ù†Ú¯Ø§Ù† Ø¨Ùˆ ÙˆÛŒ Ù†Û•Ù‡Ø§Øª.<br>-Ø¦Û•Ú¯Û•Ø± Ø¯Û•Ù… Ø¯ÙˆÙ…Ø§Ù‡ÛŒÚ© Ù‡Ø§Øª.`,
                room: "Ø±ÙˆÙˆÙ…", playWithFriends: " Ø±ÙˆÙˆÙ… ", createRoom: "Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ù†Ø§ Ø±ÙˆÙˆÙ…Û", joinRoom: "Ú†ÙˆÙˆÙ†Û• Ú˜ÙˆÙˆØ±", roomCode: "Ú©Û†Ø¯Ø§ Ø±ÙˆÙˆÙ…Û:", enterCode: "Ú©Û†Ø¯Ø§ Ø±ÙˆÙˆÙ…Û Ø¨Ù†Ú¤ÛŒØ³Û•", creator: "Ø¯Ø±ÙˆØ³ØªÚ©Û•Ø±", myStatus: "Ø¯Û†Ø®:", waitingForName: "Ù‡ÛŒÚ¤ÛŒØ§ Ù†Ú¤ÛŒØ³ÛŒÙ†Ø§ Ù†Ø§Ú¤ÛŒ", waitingForOthers: "Ù‡ÛŒÚ¤ÛŒØ§ ÛŒØ§Ø±ÛŒÚ©Û•Ø±ÛÙ† Ø¯ÛŒ Ø¨Û• ", ready: "Ø¦Ø§Ù…Ø§Ø¯Û•ÛŒÛ•", submit: "Ù¾Ø´ØªØ±Ø§Ø³ØªÚ©Ø±Ù†", notEnoughPlayersPopup: "Ú˜Ù…Ø§Ø±Ø§ ÛŒØ§Ø±ÛŒÚ©Û•Ø±Ø§Ù† ÛŒØ§ Ú©ÛÙ…Û•ØŒ Ø¯Ú¤ÛØª Ø¨ Ú©ÛÙ…ÛŒ Ù£ ÛŒØ§Ø±ÛŒÚ©Û•Ø± Ø¨Ù†.", roomFull: "Ø±ÙˆÙˆÙ… ÛŒØ§ Ù¾Ú•Û•.", roomNotFound: "Ú©Û†Ø¯Ø§ Ø±ÙˆÙˆÙ…Û ÛŒØ§ Ø®Û•Ù„Û•ØªÛ•.", roomStart: "Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ù†", gameAlreadyStarted: "ÛŒØ§Ø±ÛŒ ÛŒØ§ Ù‡Ø§ØªÛŒÛ• Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ù†...", enterYourName: "Ù†Ø§Ú¤Û Ø®Ùˆ Ø¨Ù†Ú¤ÛŒØ³Û•", nameSubmitSuccess: " Ù†Ø§Ú¤Û ØªÛ• Ù‡Ø§ØªÛ• Ù†Ú¤ÛŒØ³ÛŒÙ†ØŒ Ù‡ÛŒÚ¤ÛŒØ§ ÛŒÛÙ† Ø¯ÛŒ Ø¨Û•.", gameOverTitle: "Ø¯ÙˆÙ…Ø§Ù‡ÛŒÚ© Ø¦ÛŒÙ†Ø§Ù†Ø§ ÛŒØ§Ø±ÛŒÛ", playAgain: "Ø¯ÙˆÙˆØ¨Ø§Ø±Û• ÛŒØ§Ø±ÛŒÛ Ø¨Ú©Û•Ú¤Û•", exitRoom: "Ø¯Û•Ø±Ú†ÙˆÙˆÙ†", startOver: "Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø§ ÛŒØ§Ø±ÛŒÛ ( Ù¾Û•ÛŒÚ¤Ø§ Ù†Ù‡ÛÙ†ÛŒ Ùˆ Ø±ÙˆÙ„Û ØªÛ• )", backToSetup: "Ø²Ú¤Ø±ÛŒÙ†Û•Ú¤Û• Ø¨Û† Ú•ÛÚ©Ø®Ø³ØªÙ†Ø§Ù†",
                finishTheTimer: "Ø¯ÙˆÙ…Ø§Ù‡ÛŒÚ© Ø¦ÛŒÙ†Ø§Ù†Ø§ Ø¯Û•Ù…ÛŒ", remove: "Ú˜ÛØ¨Ø±Ù†", chatTitle: "Ú¯ÙØªÙˆÚ¯ÙˆÛŒØ§ ÛŒØ§Ø±ÛŒÚ©Û•Ø±Ø§Ù†", onlineCountLabel: "Online"
            }
        };
        return translations.ku[key] || key;
    };
    
    // --- NEW: Online Presence LOGIC ---
    const setupOnlinePresence = () => {
         // 1. Reference to the location where we will store online users
         presenceRef = database.ref('presence');
         
         // 2. Reference to the Firebase server's connection status
         const connectedRef = database.ref(".info/connected");
         
         connectedRef.on("value", (snapshot) => {
             if (snapshot.val() === true) {
                 // The user is connected
                 myConnectionRef = presenceRef.push();
                 
                 // 3. Remove this user from the 'presence' list when they disconnect
                 myConnectionRef.onDisconnect().remove();
                 
                 // 4. Set the user's data (could be just a timestamp or ID)
                 myConnectionRef.set(true); 
                 
                 // 5. Start listening for the count of online users
                 presenceRef.on('value', updateOnlineCount);
             } else {
                 // The user is disconnected
                 if(myConnectionRef) {
                    myConnectionRef.remove();
                    myConnectionRef = null;
                 }
                 presenceRef.off('value', updateOnlineCount);
                 onlineCounter.textContent = `${T('onlineCountLabel')} (0)`; 
             }
         });
    };
    
    const updateOnlineCount = (snapshot) => {
         const count = snapshot.numChildren();
         onlineCounter.textContent = `${T('onlineCountLabel')} (${count})`;
    };
    // --- END Online Presence LOGIC ---


    // --- CHAT LOGIC (Not modified, but included for completeness) ---
    
    // Toggles the chat modal display and resets the unread count
    const toggleChatModal = () => {
        if (!currentRoomCode) return; // FIX: Prevent chat if not in a room

        if (chatModal.classList.contains('show')) {
            chatModal.classList.remove('show');
        } else {
            chatModal.classList.add('show');
            
            // Reset unread counter when opening the chat
            unreadCountSpan.style.display = 'none';
            unreadCountSpan.textContent = '';
            lastKnownMessageCount = 0; // Reset counter value too
            
            // Scroll to the bottom to see the latest messages
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
    };
    
    // Sends a message to the Firebase chat database
    const sendMessage = () => {
        const messageText = chatInput.value.trim();
        
        // **NEW: Check for player name**
        if (!myPlayerName) {
            showModal('validationTitle', 'enterYourName');
            chatInput.value = ''; // Clear input if message wasn't sent
            return;
        }

        if (!messageText || !currentRoomCode) return;

        chatRef.child(currentRoomCode).push({
            senderId: myPlayerId,
            senderName: myPlayerName,
            message: messageText,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });

        chatInput.value = '';
    };

    // Displays the messages in the container
    const displayMessage = (senderId, senderName, message, timestamp, messageKey) => { 
        
        // **Ú†Ø§Ø±Û•Ø³Û•Ø±ÛŒ Ø¯ÙˆÙˆØ¨Ø§Ø±Û•Ø¨ÙˆÙˆÙ†Û•ÙˆÛ•: Ù¾Ø´Ú©Ù†ÛŒÙ† Ø¨Û† Ø¦Û•ÙˆÛ•ÛŒ Ø¨Ø²Ø§Ù†ÛŒÙ† Ù¾Û•ÛŒØ§Ù…Û•Ú©Û• Ù¾ÛØ´ØªØ± Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ø§ÙˆÛ• ÛŒØ§Ù† Ù†Ø§**
        if (document.getElementById(`msg-${messageKey}`)) {
            return;
        }
        
        const time = new Date(timestamp).toLocaleTimeString('ku-IQ', { hour: '2-digit', minute: '2-digit' });
        const isMe = senderId === myPlayerId;
        
        // **NEW: Get player color index**
        const colorIndex = playerColorMap[senderId] !== undefined ? playerColorMap[senderId] : 0;
        const colorClass = `player-color-${colorIndex % 12}`;
        
        const messageDiv = document.createElement('div');
        messageDiv.id = `msg-${messageKey}`; // Ø¯Ø§Ù†Ø§Ù†ÛŒ ID Ø¨Û† Ù¾Û•ÛŒØ§Ù…Û•Ú©Û•
        messageDiv.className = `message-item text-right`; 
        messageDiv.innerHTML = `
            <span class="sender-name ${colorClass}">${senderName}:</span> 
            <span class="message-text">${message}</span>
            <span class="text-xs text-slate-500 mr-2">${time}</span>
        `;
        
        // Use insertBefore to keep the newest message at the bottom (due to flex-direction: column-reverse)
        messagesContainer.insertBefore(messageDiv, messagesContainer.firstChild);

        if (chatModal.classList.contains('show')) {
             messagesContainer.scrollTop = messagesContainer.scrollHeight; // Keep chat scrolled to bottom when open
        }
    };
    
    // Listens for new messages in the specific room
    const listenForMessages = (roomCode) => {
        if (!chatDatabase) return;
        
        // Remove previous listener if it exists
        if (chatRef) {
             chatRef.off();
        }
        messagesContainer.innerHTML = ''; // Clear old messages
        lastKnownMessageCount = 0;
        unreadCountSpan.style.display = 'none';

        chatRef = chatDatabase.ref('messages');
        const roomChatRef = chatRef.child(roomCode);

        // Initial fetch and on-new-child listener
        roomChatRef.limitToLast(50).on('child_added', (snapshot) => {
            const messageData = snapshot.val();
            const messageKey = snapshot.key; // **New: Get the message key**
            
            // Check if the message is new (for unread count)
            if (!chatModal.classList.contains('show') && messageData.senderId !== myPlayerId) {
                 // Only count as unread if the message is new to the container
                 if (!document.getElementById(`msg-${messageKey}`)) {
                     lastKnownMessageCount++;
                     if (lastKnownMessageCount > 0) {
                        unreadCountSpan.style.display = 'flex';
                        unreadCountSpan.textContent = lastKnownMessageCount;
                     }
                 }
            }

            displayMessage(
                messageData.senderId, 
                messageData.senderName, 
                messageData.message, 
                messageData.timestamp,
                messageKey // **New: Pass the message key**
            );
        }, (error) => {
             console.error("Firebase Chat Listener Error:", error);
        });
    };
    
    // Hides the chat button and removes the chat listener
    const stopChat = () => {
        chatButton.style.display = 'none';
        chatModal.classList.remove('show');
        unreadCountSpan.style.display = 'none';
        if (chatRef) {
             chatRef.off();
        }
        chatRef = null;
        lastKnownMessageCount = 0;
    };
    
    // Shows the chat button and starts the chat listener
    const startChat = (roomCode) => {
        chatButton.style.display = 'flex';
        listenForMessages(roomCode);
    };

    // --- END CHAT LOGIC ---

    const formatTime = (seconds) => {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    };

    const showModal = (titleKey, messageKey, isImposterReveal = false, customContent = null, closeCallback = hideModal) => {
        const title = T(titleKey);
        let message = T(messageKey);
        
        if(isImposterReveal) {
             message = messageKey;
        }
        
        modalInner.className = 'modal-content ' + (isImposterReveal ? 'imposter-popup' : '');
        modalInner.innerHTML = `
            <button class="modal-close-btn" onclick="${closeCallback.name}()">Ã—</button>
            <h3 class="modal-title">${title}</h3>
            <div class="modal-message">
                ${customContent || message}
            </div>
            ${!isImposterReveal ? `<button class="primary-btn" onclick="${closeCallback.name}()">
                ${T('close')}
            </button>` : `<button class="primary-btn mt-4" onclick="${closeCallback.name}()">
                ${T('close')}
            </button>`}
        `;
        modal.classList.add('show');
    };

    const hideModal = () => {
        modal.classList.remove('show');
    };

    const shareGameLink = async () => {
        if (!currentRoomCode && isRoomMode) return;
        
        let url = window.location.href.split('?')[0];
        let shareText = T('shareLink');
        
        if (isRoomMode) {
           url = url + `?room=${currentRoomCode}`;
           shareText = `${T('roomCode')} ${currentRoomCode}. ${T('shareLink')}`;
        }
        
        if (navigator.share) {
            try {
                await navigator.share({
                    title: T('appName'),
                    text: shareText,
                    url: url
                });
            } catch (error) {
                await navigator.clipboard.writeText(url);
                showModal('roomCode', `${isRoomMode ? currentRoomCode : url}<br><br><strong>${T('shareLink')}</strong>`);
            }
        } else {
            await navigator.clipboard.writeText(url);
            showModal('roomCode', `${isRoomMode ? currentRoomCode : url}<br><br><strong>${T('shareLink')}</strong>`);
        }
    };

    const showHelpModal = () => {
        showModal('howToPlayTitle', 'howToPlayBody', false, T('howToPlayBody'));
    };

    const getRoomSnapshot = async (code) => {
        try {
            const snapshot = await database.ref('rooms/' + code).once('value');
            return snapshot.val();
        } catch (error) {
            console.error("Error getting room snapshot:", error);
            return null;
        }
    };

    const startRoomPolling = () => {
        if (!currentRoomCode) return;
        
        if (roomRef) roomRef.off('value', pollRoomCallback);

        roomRef = database.ref('rooms/' + currentRoomCode);
        
        roomRef.on('value', pollRoomCallback, (error) => {
            console.error("Firebase listener error:", error);
            if (currentRoomCode) {
                showModal('validationTitle', 'roomNotFound', false, null, resetGame);
            }
        });
    };

    const stopRoomPolling = () => {
        if (roomRef) {
            roomRef.off('value', pollRoomCallback);
            roomRef = null;
        }
    };
    
    const pollRoomCallback = (snapshot) => {
        const room = snapshot.val();
        
        if (!room) {
            stopRoomPolling();
            stopChat(); 
            if (currentRoomCode) {
                showModal('validationTitle', 'roomNotFound', false, null, resetGame);
            }
            return;
        }
        
        if (isInputFocused) {
           return;
        }

        if (myPlayerId && !room.players.some(p => p.id === myPlayerId)) {
            stopRoomPolling();
            stopChat(); 
            resetGame();
            return;
        }
        
        isRoomCreator = room.creatorId === myPlayerId; 
        imposterCount = room.imposterCount;
        playerCount = room.players.length;
        
        const myPlayerData = room.players.find(p => p.id === myPlayerId);
        if (myPlayerData) {
             roles = room.players;
             secretWord = room.secretWord;
             imposterHintWord = room.imposterHintWord;
             myPlayerName = myPlayerData.name || ''; 
        }

        // **NEW: Update player color map**
        playerColorMap = {};
        room.players.forEach((player, index) => {
            playerColorMap[player.id] = index;
        });

        if (room.gameState === 'playing' && !isGameStartedInRoom) {
            isGameStartedInRoom = true;
            startGame(room);
        } else if (room.gameState === 'ended' && isGameStartedInRoom) {
            renderGameOverModal();
        } else if (room.gameState === 'setup') {
            if (!isGameStartedInRoom) {
               renderRoomLobby(room);
            } else {
                 isGameStartedInRoom = false;
                 roles = [];
                 clearInterval(timerInterval);
                 timerInterval = null;
                 timeLeft = null;
                 renderRoomLobby(room);
            }
        } else if (room.gameState === 'playing' && isGameStartedInRoom) {
            renderEndGameView(true);
        }
        
        // **Ú¯Û†Ú•Ø§Ù†Ú©Ø§Ø±ÛŒ: Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ø¯Ù†ÛŒ Ú†Ø§Øª Ù„Û• Ù‡Û•Ø± Ø¯Û†Ø®ÛÚ©ÛŒ Ú˜ÙˆÙˆØ±Ø¯Ø§**
        if (currentRoomCode && room.gameState !== 'menu' && room.gameState !== 'setup') {
             // Ú†Ø§ØªÛ•Ú©Û• Ù„Û• renderRoomLobby Ø¯Û•Ø³ØªÙ¾ÛØ¯Û•Ú©Ø§ØªØŒ Ø¨Û•ÚµØ§Ù… Ø¦Û•Ù…Û• Ø¯ÚµÙ†ÛŒØ§ Ø¯Û•Ø¨ÛØªÛ•ÙˆÛ• Ú©Û• Ø¦Û•Ú¯Û•Ø± Ù„Û• Ù‡Û•Ø± Ø¯Û†Ø®ÛÚ©ÛŒ ØªØ±Ø¯Ø§ Ø¨ÙˆÙˆ (ÙˆÛ•Ú© playing/ended)ØŒ Ú†Ø§Ù„Ø§Ú© Ø¯Û•Ø¨ÛØª.
             startChat(currentRoomCode); 
        } else if (currentRoomCode && room.gameState === 'setup') {
             startChat(currentRoomCode);
        } else {
             stopChat();
        }
    };

    const generateRoomCode = () => {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let code = '';
        for (let i = 0; i < 4; i++) {
            code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return code;
    };

    const createRoom = async () => {
        let code = generateRoomCode();
        let existingRoom = await getRoomSnapshot(code);
        while (existingRoom) {
            code = generateRoomCode();
            existingRoom = await getRoomSnapshot(code);
        }
        
        myPlayerId = database.ref().push().key; 
        
        const newRoom = {
            code: code,
            creatorId: myPlayerId,
            imposterCount: 1,
            players: [
                { id: myPlayerId, name: '', isReady: false, role: '', word: '' }
            ],
            gameState: 'setup',
            secretWord: '',
            imposterHintWord: '',
            discussionStartTime: null,
            discussionDuration: 0
        };
        
        roomRef = database.ref('rooms/' + code);
        await roomRef.set(newRoom);
        
        currentRoomCode = code;
        isRoomCreator = true;
        isRoomMode = true;
        
        renderRoomLobby(newRoom);
        startRoomPolling();
    };

    const joinRoom = async (code) => {
        code = code.toUpperCase();
        const room = await getRoomSnapshot(code);
        
        if (!room) {
            showModal('validationTitle', 'roomNotFound');
            return;
        }
        if (room.players.length >= 12) {
            showModal('validationTitle', 'roomFull');
            return;
        }
        
        myPlayerId = database.ref().push().key; 
        const newPlayer = { id: myPlayerId, name: '', isReady: false, role: '', word: '' };
        
        roomRef = database.ref('rooms/' + code);
        room.players.push(newPlayer);
        await roomRef.update({ players: room.players });
        
        currentRoomCode = code;
        isRoomCreator = room.creatorId === myPlayerId;
        isRoomMode = true;
        
        renderRoomLobby(room);
        startRoomPolling();
    };

    const submitName = async () => {
        const nameInput = document.getElementById('my-name-input');
        const name = nameInput.value.trim();
        
        if (name.length < 1) {
            showModal('validationTitle', 'nameRequired');
            return;
        }
        
        isInputFocused = true;
        const room = await getRoomSnapshot(currentRoomCode);
        isInputFocused = false;
        if (!room) return;
        
        myPlayerName = name; // Store player name globally

        const myPlayerIndex = room.players.findIndex(p => p.id === myPlayerId);
        if (myPlayerIndex !== -1) {
            room.players[myPlayerIndex].name = name;
            room.players[myPlayerIndex].isReady = true;
            
            await roomRef.update({ players: room.players });
            
            showModal('validationTitle', 'nameSubmitSuccess', false, null, hideModal);
        }
    };
    
    const updateRoomSettings = async (imposterValue) => {
        if (!isRoomCreator) return;
        
        let count = parseInt(imposterValue);
        const room = await getRoomSnapshot(currentRoomCode);
        
        if (!room) return;

        if (isNaN(count) || count < 1) count = 1;
        if (count > 2) count = 2;
        if (count >= room.players.length && room.players.length > 1) {
            count = room.players.length - 1;
        }
        if (count < 1 && room.players.length > 0) count = 1;

        if (roomRef) {
            await roomRef.update({ imposterCount: count });
            imposterCount = count;
        }
    };

    // New function to remove a player
    const removePlayerFromRoom = async (playerIdToRemove) => {
        if (!isRoomCreator || playerIdToRemove === myPlayerId) return; 

        isInputFocused = true;
        const room = await getRoomSnapshot(currentRoomCode);
        isInputFocused = false;
        if (!room) return;

        const updatedPlayers = room.players.filter(p => p.id !== playerIdToRemove);

        if (updatedPlayers.length === 0) {
            await database.ref('rooms/' + currentRoomCode).remove();
        } else {
            let updates = { players: updatedPlayers };
            // If the removed player was the creator, assign new creator (the first player in the list)
            if (room.creatorId === playerIdToRemove) {
                 updates.creatorId = updatedPlayers[0].id;
            }
            await database.ref('rooms/' + currentRoomCode).update(updates);
        }
    };


    const startRoomGame = async () => {
        const room = await getRoomSnapshot(currentRoomCode);
        if (!room || room.players.length < 3) {
            renderNotEnoughPlayersModal();
            return;
        }
        
        const readyPlayers = room.players.filter(p => p.isReady && p.name);
        if (readyPlayers.length < room.players.length) {
            showModal('validationTitle', 'nameRequired');
            return;
        }
        
        const wordList = getWordList();
        const secretIndex = Math.floor(Math.random() * wordList.length);
        const newSecretWord = wordList[secretIndex];
        const newImposterHintWord = T('justImposter');
        
        const imposterIndices = [];
        while (imposterIndices.length < room.imposterCount) {
            const index = Math.floor(Math.random() * readyPlayers.length);
            if (!imposterIndices.includes(index)) {
                imposterIndices.push(index);
            }
        }
        
        let rolesList = readyPlayers.map((p, i) => {
            const isImposter = imposterIndices.includes(i);
            const role = isImposter ? T('imposter') : T('civilian');
            const wordContent = isImposter ? newImposterHintWord : newSecretWord;
            
            return {
                ...p,
                role: role,
                word: wordContent,
                name: p.name.trim(),
            };
        });

        rolesList = rolesList.sort(() => Math.random() - 0.5);
        
        room.players = rolesList;
        room.secretWord = newSecretWord;
        room.imposterHintWord = newImposterHintWord;
        room.gameState = 'playing';
        
        roles = rolesList;

        await roomRef.update({
            players: room.players,
            secretWord: room.secretWord,
            imposterHintWord: room.imposterHintWord,
            gameState: room.gameState
        });

        isGameStartedInRoom = true;
        startGame(room);
    };

    // --- MODIFIED: The function to keep players ready ---
    const resetRoomGame = async () => {
        const room = await getRoomSnapshot(currentRoomCode);
        if (!room) return;
        
        // --- NEW LOGIC: Only reset role and word, keep name and isReady if name exists ---
        const updates = {
            gameState: 'setup',
            secretWord: '',
            imposterHintWord: '',
            discussionStartTime: null,
            discussionDuration: 0,
            players: room.players.map(p => ({ 
                ...p, 
                // Keep the name and ready status if a name was set. Reset role/word.
                isReady: p.name && p.name.length > 0, 
                role: '', 
                word: '' 
            })) 
        };
        // ---------------------------------------------------------------------------------
        
        await roomRef.update(updates);
        
        isGameStartedInRoom = false;
        roles = [];
        clearInterval(timerInterval);
        timerInterval = null;
        timeLeft = null;
        
        hideModal();
    };

    const finishRoomTimer = async () => {
        if (!isRoomMode || !isRoomCreator) return;
        
        if (roomRef) {
            clearInterval(timerInterval);
            timerInterval = null;
            timeLeft = 0;
            await roomRef.update({ gameState: 'ended' });
            renderGameOverModal();
        }
    };
    
    const finishLocalTimer = () => {
        clearInterval(timerInterval);
        timerInterval = null;
        timeLeft = 0;
        
        // --- Ù†ÙˆÛÚ©Ø±Ø§ÙˆÛ• Ø¨Û† Ø¯Û†Ø®ÛŒ Ø¦Ø§Ø³Ø§ÛŒÛŒ ---
        document.getElementById('timerDisplay').textContent = T('timesUp');
        
        const imposterNames = roles
            .filter(r => r.role === T('imposter'))
            .map(r => r.name);
        const imposterList = imposterNames.join(' ' + T('and') + ' ');
        
        const message = `
            <div class="text-right">
                <p class="text-lg text-slate-300 mb-2">${T('wordWas')}</p>
                <p class="text-2xl font-bold text-primary mb-4">${secretWord}</p>
                <p class="text-lg text-slate-300 mb-2">${T('impostersWere')}</p>
                <p class="text-2xl font-bold word-imposter">${imposterList}</p>
            </div>
        `;
        showModal('gameOverTitle', '', true, message);
    }

    const timerFinished = async () => {
        clearInterval(timerInterval);
        timerInterval = null;
        
        if(isRoomMode) {
            if(isRoomCreator) {
                await roomRef.update({ gameState: 'ended' });
                renderGameOverModal();
            }
        } else {
            finishLocalTimer();
        }
    }

    const countdown = () => {
        if (timeLeft <= 0) {
            timerFinished();
        } else {
            timeLeft--;
            const timerEl = document.getElementById('timerDisplay');
            if(timerEl) timerEl.textContent = `${T('discussionTime')} ${formatTime(timeLeft)}`;
        }
    }
    
    const startDiscussion = async () => {
        if (timerInterval) return;

        const duration = playerCount * 60;

        if (isRoomMode) {
            if (isRoomCreator) {
                const room = await getRoomSnapshot(currentRoomCode);
                if (room && room.gameState === 'playing') {
                    
                    await roomRef.update({
                        discussionStartTime: firebase.database.ServerValue.TIMESTAMP,
                        discussionDuration: duration
                    });
                    
                    timeLeft = duration;
                    timerInterval = setInterval(countdown, 1000); 
                    
                    const startButton = document.getElementById('startDiscussionButton');
                    if(startButton) {
                       startButton.textContent = T('discussionTime');
                       startButton.disabled = true;
                    }
                    const timerEl = document.getElementById('timerDisplay');
                    if(timerEl) timerEl.textContent = `${T('discussionTime')} ${formatTime(timeLeft)}`;
                    
                    const endBtn = document.getElementById('finishLocalTimerButton');
                    if(endBtn) endBtn.classList.remove('hidden');
                    
                    // startChat(currentRoomCode); // Already started in pollRoomCallback
                }
            }
        } else {
            timeLeft = duration; 
            const startButton = document.getElementById('startDiscussionButton');
            startButton.textContent = T('discussionTime');
            startButton.disabled = true;
            document.getElementById('timerDisplay').textContent = `${T('discussionTime')} ${formatTime(timeLeft)}`;
            timerInterval = setInterval(countdown, 1000); 
            
            // --- Ù†ÙˆÛÚ©Ø±Ø§ÙˆÛ• Ø¨Û† Ø¯Û†Ø®ÛŒ Ø¦Ø§Ø³Ø§ÛŒÛŒ ---
            const endBtn = document.getElementById('finishLocalTimerButton');
            if(endBtn) endBtn.classList.remove('hidden');
        }
    };
    
    const renderEndGameView = (isRoom = false) => {
        const container = document.getElementById('game-container');
        
        const initialTime = playerCount * 60;
        const initialTimeFormatted = formatTime(initialTime);
        let displayTime = timerInterval ? `${T('discussionTime')} ${formatTime(timeLeft)}` : `${T('discussionTime')} ${initialTimeFormatted}`;
        
        
        if (isRoom && roomRef && !isRoomCreator) {
            roomRef.once('value').then(snapshot => {
                const room = snapshot.val();
                const timerEl = document.getElementById('timerDisplay');
                
                if(room && room.discussionStartTime && room.discussionDuration) {
                    const elapsed = Date.now() - room.discussionStartTime;
                    const remaining = room.discussionDuration * 1000 - elapsed;
                    
                    if(remaining > 0) {
                        timeLeft = Math.ceil(remaining / 1000);
                        if (timerEl) timerEl.textContent = `${T('discussionTime')} ${formatTime(timeLeft)}`;
                        if (!timerInterval) {
                             timerInterval = setInterval(countdown, 1000); 
                        }
                    } else {
                         if (timerEl) timerEl.textContent = T('timesUp');
                    }
                } else {
                     if (timerEl) timerEl.textContent = T('waitingForOthers');
                }
            });
            displayTime = T('waitingForOthers');
        }
        
        if (isRoom && !isRoomCreator) {
            const roomData = roles.find(p => p.id === myPlayerId);
             if (roomData && roomData.role) {
                secretWord = roles.find(p => p.role === T('civilian'))?.word || '';
                imposterHintWord = T('justImposter');
                
                container.innerHTML = `
                    <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
                    <h2 class="text-xl font-bold text-center text-slate-300 mb-6">${T('turn')}</h2>
                    <div class="title-bar mb-6"></div>
                    
                    <div class="player-card">
                        <p class="text-lg text-slate-300 mb-2">${roomData.name}</p>
                        <p class="role-text-simplified ${roomData.role === T('imposter') ? 'word-imposter' : 'word-civilian'}">
                           ${roomData.role === T('imposter') ? T('justImposter') : roomData.word}
                        </p>
                    </div>

                    <p id="timerDisplay" class="text-2xl text-slate-200 text-center mt-6 mb-4">${displayTime}</p>
                    <button id="startDiscussionButton" class="primary-btn mb-6 opacity-50 cursor-not-allowed" 
                            disabled style="background: linear-gradient(145deg, #6366f1, #4f46e5); color: white;">
                        ${T('startDiscussion')}
                    </button>
                    <p class="text-sm text-center text-slate-400">${T('waitingForOthers')}</p>
                    
                    <div class="mt-8">
                        <button class="back-btn mt-2" onclick="exitRoom()">
                            ${T('exitRoom')}
                        </button>
                    </div>
                    <div class="footer-text mt-8">${T('madeBy')} <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a></div>
                `;
                return;
            }
        }
        
        container.innerHTML = `
             <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
             <h2 id="timerDisplay" class="text-2xl text-slate-200 text-center mb-6">${displayTime}</h2>
             <div class="title-bar mb-6"></div>

             <button id="startDiscussionButton" class="primary-btn mb-6 ${isRoom && !isRoomCreator ? 'opacity-50 cursor-not-allowed' : ''}" 
                     onclick="startDiscussion()" 
                     ${isRoom && !isRoomCreator ? 'disabled' : ''}
                     style="background: linear-gradient(145deg, #6366f1, #4f46e5); color: white;">
                 ${T('startDiscussion')}
             </button>

             ${isRoom && isRoomCreator ? `
                 <button class="primary-btn secondary-btn mb-4" onclick="finishRoomTimer()" style="background: linear-gradient(145deg, #f87171, #ef4444); color: white;">
                     ${T('finishTheTimer')}
                 </button>
             ` : !isRoom ? `
                 <button id="finishLocalTimerButton" class="primary-btn secondary-btn mb-4 hidden" onclick="finishLocalTimer()" style="background: linear-gradient(145deg, #f87171, #ef4444); color: white;">
                     ${T('finishTheTimer')}
                 </button>
             ` : ''}

             <div class="mt-8">
                 ${isRoom ? `
                    <button class="primary-btn bg-secondary hover:bg-indigo-600 mb-4" onclick="resetRoomGame()" ${!isRoomCreator ? 'disabled' : ''} style="background: linear-gradient(145deg, #facc15, #eab308); color: #1e293b;">
                         ${T('startOver')}
                     </button>
                    <button class="back-btn mt-2" onclick="exitRoom()">
                        ${T('exitRoom')}
                    </button>
                 ` : `
                    <button class="primary-btn bg-secondary hover:bg-indigo-600" onclick="resetGame()" style="background: linear-gradient(145deg, #facc15, #eab308); color: #1e293b;">
                         ${T('reset')}
                     </button>
                 `}
             </div>
           
             <div class="footer-text mt-8">
                 ${T('madeBy')}
                 <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a>
             </div>
         `;
         
         if(timerInterval) {
             const startButton = document.getElementById('startDiscussionButton');
             if(startButton) {
                 startButton.textContent = T('discussionTime');
                 startButton.disabled = true;
             }
             const endBtn = document.getElementById('finishLocalTimerButton');
             if(endBtn && !isRoom) endBtn.classList.remove('hidden');
         }
         
         // **Ù„Ø§Ø¯Ø§Ù†ÛŒ Ø¨Ø§Ù†Ú¯Ú©Ø±Ø¯Ù†ÛŒ Ú†Ø§Øª Ù„ÛØ±Û•ØŒ Ú†ÙˆÙ†Ú©Û• Ù„Û• pollRoomCallback Ø¯Û•Ø³ØªÛŒÙ¾ÛÚ©Ø±Ø¯ÙˆÙˆÛ•**
         // if (isRoom && (timerInterval || displayTime === T('waitingForOthers'))) {
         //     startChat(currentRoomCode);
         // }
    };
    
    const getNamesFromDOM = () => {
         const inputs = document.querySelectorAll('#player-names-input input[type="text"]');
         playerNames = Array.from(inputs).map(input => input.value.trim());
         return playerNames;
    };
    
    const startGame = (roomData = null) => {
        hideModal();
        gameActive = true;
        
        if (roomData) {
            isRoomMode = true;
            roles = roomData.players;
            playerCount = roles.length;
            imposterCount = roomData.imposterCount;
            secretWord = roomData.secretWord;
            imposterHintWord = roomData.imposterHintWord;
            
            const myPlayerIndex = roles.findIndex(p => p.id === myPlayerId);
            myPlayerName = roles[myPlayerIndex].name; // Ensure myPlayerName is set
            renderRoomGameView(myPlayerIndex);
            
        } else {
            // Local game logic
            playerNames = getNamesFromDOM().filter(n => n.length > 0);
            playerCount = playerNames.length;
            
            if (playerCount < 3) {
                 renderNotEnoughPlayersModal();
                 gameActive = false;
                 return;
            }
            if (playerNames.some(name => name.length < 1)) {
                 showModal('validationTitle', 'nameRequired');
                 gameActive = false;
                 return;
            }

            const wordList = getWordList();
            const secretIndex = Math.floor(Math.random() * wordList.length);
            secretWord = wordList[secretIndex];
            imposterHintWord = T('justImposter');
            
            const imposterIndices = [];
            while (imposterIndices.length < imposterCount) {
                const index = Math.floor(Math.random() * playerCount);
                if (!imposterIndices.includes(index)) {
                    imposterIndices.push(index);
                }
            }
            
            roles = playerNames.map((name, i) => {
                const isImposter = imposterIndices.includes(i);
                return {
                    name: name,
                    role: isImposter ? T('imposter') : T('civilian'),
                    word: isImposter ? imposterHintWord : secretWord
                };
            }).sort(() => Math.random() - 0.5);

            renderPlayerTurnView(0);
        }
    };

    const showRole = (playerIndex) => {
        const roleData = isRoomMode ? roles.find(p => p.id === myPlayerId) : roles[playerIndex];
        
        if (!roleData) return;
        
        const isImposter = roleData.role === T('imposter');
        const roleContent = isImposter 
            ? `<p class="role-text-simplified word-imposter">${T('justImposter')}</p>`
            : `<p class="role-text-simplified word-civilian">${roleData.word}</p>`;

        const container = isRoomMode ? document.getElementById('room-player-turn') : document.getElementById('player-turn-view');
        
        container.innerHTML = `
            <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
            <h2 class="text-xl font-bold text-center text-slate-300 mb-6">${T('yourRole')}</h2>
            <div class="title-bar mb-6"></div>

            <div class="player-card">
                <p class="text-lg text-slate-300 mb-2">${roleData.name}</p>
                ${roleContent}
            </div>
            
            <button class="primary-btn mt-6" onclick="hideRole(${playerIndex})">
                ${T('close')}
            </button>
        `;
    };

    const hideRole = (playerIndex) => {
        if (isRoomMode) {
            renderEndGameView(true);
        } else if (playerIndex < roles.length - 1) {
            renderPlayerTurnView(playerIndex + 1);
        } else {
            renderEndGameView(false);
        }
    };
    
    const renderPlayerTurnView = (playerIndex = 0) => {
        const container = document.getElementById('game-container');
        const currentPlayer = roles[playerIndex];
        const totalPlayers = roles.length;

        container.innerHTML = `
            <div id="player-turn-view">
                <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
                <h2 class="text-xl font-bold text-center text-slate-300 mb-6">${T('turn')} ${playerIndex + 1}/${totalPlayers}</h2>
                <div class="title-bar mb-6"></div>

                <div class="player-card">
                    <p class="text-lg text-slate-300 mb-2">${T('playerName')}:</p>
                    <p class="text-3xl font-bold text-primary">${currentPlayer.name}</p>
                </div>

                <button class="primary-btn mt-6" onclick="showRole(${playerIndex})">
                    ${T('showRole')}
                </button>
                
                <button class="back-btn" onclick="resetGame()">
                    ${T('backToSetup')}
                </button>
                 <div class="footer-text mt-8">${T('madeBy')} <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a></div>
            </div>
        `;
    };
    
    const renderRoomGameView = (myPlayerIndex) => {
        const container = document.getElementById('game-container');
        const myPlayerData = roles.find(p => p.id === myPlayerId);
        
        if (!myPlayerData) return;

        container.innerHTML = `
            <div id="room-player-turn">
                <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
                <h2 class="text-xl font-bold text-center text-slate-300 mb-6">${T('turn')}</h2>
                <div class="title-bar mb-6"></div>

                <div class="player-card">
                    <p class="text-lg text-slate-300 mb-2">${T('playerName')}:</p>
                    <p class="text-3xl font-bold text-primary">${myPlayerData.name}</p>
                </div>

                <button class="primary-btn mt-6" onclick="showRole(${myPlayerIndex})">
                    ${T('showRole')}
                </button>
                
                <button class="back-btn" onclick="exitRoom()">
                    ${T('exitRoom')}
                </button>
                 <div class="footer-text mt-8">${T('madeBy')} <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a></div>
            </div>
        `;
    };
    
    const renderGameOverModal = () => {
        stopChat(); 
        const imposterNames = roles
            .filter(r => r.role === T('imposter'))
            .map(r => r.name);
        const imposterList = imposterNames.join(' ' + T('and') + ' ');
        
        const message = `
            <div class="text-right">
                <p class="text-lg text-slate-300 mb-2">${T('wordWas')}</p>
                <p class="text-2xl font-bold text-primary mb-4">${secretWord}</p>
                <p class="text-lg text-slate-300 mb-2">${T('impostersWere')}</p>
                <p class="text-2xl font-bold word-imposter">${imposterList}</p>
            </div>
            <button class="primary-btn mt-6 mb-2" onclick="${isRoomCreator ? 'resetRoomGame()' : 'hideModal()'}">
                ${isRoomCreator ? T('playAgain') : T('close')}
            </button>
            <button class="back-btn mt-2" onclick="exitRoom()">
                ${T('exitRoom')}
            </button>
        `;

        showModal('gameOverTitle', '', true, message, hideModal);
    };

    const renderNotEnoughPlayersModal = () => {
        showModal('validationTitle', 'notEnoughPlayersPopup');
    };

    const renderSetupView = () => {
        isRoomMode = false;
        gameActive = false;
        helpButton.classList.remove('hidden');
        stopChat(); 
        myPlayerName = ''; 
        playerColorMap = {}; 

        const container = document.getElementById('game-container');
        
        if (playerNames.length !== playerCount) {
             playerNames = Array(playerCount).fill('').map((_, i) => playerNames[i] || '');
        }

        const nameInputs = playerNames.map((name, index) => `
            <input type="text" placeholder="${T('playerName')} ${index + 1}" value="${name}" 
                   onfocus="isInputFocused = true" 
                   onblur="isInputFocused = false" 
                   onchange="getNamesFromDOM()">
        `).join('');

        container.innerHTML = `
            <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
            <div class="title-bar mb-6"></div>
            
            <p class="text-slate-300 mb-2 text-right">${T('playerCount')}</p>
            <input type="number" min="3" max="12" value="${playerCount}" onchange="handlePlayerCountChange(event)" class="mb-4">

            <p class="text-slate-300 mb-2 text-right">${T('imposterCount')}</p>
            <input type="number" min="1" max="2" value="${imposterCount}" onchange="handleImposterCountChange(event)" class="mb-6">

            <div id="player-names-input">
                <p class="text-slate-300 mb-2 text-right">${T('playerName')}:</p>
                ${nameInputs}
            </div>

            <button class="primary-btn mt-6" onclick="startGame()">
                ${T('start')}
            </button>
            
            <button class="secondary-btn" onclick="renderRoomMenu()">
                ${T('playWithFriends')}
            </button>
            
            <div class="footer-text mt-8">
                ${T('madeBy')}
                <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a>
            </div>
        `;
    };
    
    const handlePlayerCountChange = (event) => {
         let count = parseInt(event.target.value);
         if (isNaN(count) || count < 3) count = 3;
         if (count > 12) count = 12;
         playerCount = count;
         if (imposterCount >= count) {
             imposterCount = count > 1 ? 1 : 1;
         }
         
         if (playerNames.length > playerCount) {
             playerNames = playerNames.slice(0, playerCount);
         } else if (playerNames.length < playerCount) {
             for (let i = playerNames.length; i < playerCount; i++) {
                 playerNames.push('');
             }
         }
         renderSetupView();
     };

     const handleImposterCountChange = (event) => {
         let count = parseInt(event.target.value);
         if (isNaN(count) || count < 1) count = 1;
         if (count > 2 || count >= playerCount) count = Math.min(2, playerCount - 1);
         imposterCount = count;
         renderSetupView();
     };

    const renderRoomMenu = () => {
        const container = document.getElementById('game-container');
        stopChat(); 

        container.innerHTML = `
            <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
            <div class="title-bar mb-6"></div>
            
            <button class="secondary-btn mb-4" onclick="createRoom()">
                ${T('createRoom')}
            </button>
            
            <p class="text-slate-300 mb-2 text-right">${T('enterCode')}</p>
            <input type="text" id="join-code-input" placeholder="ABCD" maxlength="4" onfocus="isInputFocused = true" onblur="isInputFocused = false">
            
            <button class="primary-btn" onclick="joinRoom(document.getElementById('join-code-input').value)">
                ${T('joinRoom')}
            </button>
            
            <button class="back-btn" onclick="renderSetupView()">
                ${T('backToSetup')}
            </button>
            
            <div class="footer-text mt-8">
                ${T('madeBy')}
                <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a>
            </div>
        `;
    };
    
    const copyRoomCode = async () => {
        if (currentRoomCode) {
            await navigator.clipboard.writeText(currentRoomCode);
            showModal('roomCode', `${currentRoomCode}<br><br><strong>${T('shareLink')}</strong>`);
        }
     };

    const renderRoomLobby = (room) => {
        currentRoomCode = room.code;
        isRoomCreator = room.creatorId === myPlayerId;
        
        const myPlayerData = room.players.find(p => p.id === myPlayerId) || { name: myPlayerName, isReady: !!myPlayerName };
        myPlayerName = myPlayerData.name || ''; 
        const myStatusKey = myPlayerData.name ? (myPlayerData.isReady ? 'ready' : 'waitingForOthers') : 'waitingForName';
        
        const container = document.getElementById('game-container');
        
        shareButton.classList.remove('hidden');
        
        // **Ú¯Û†Ú•Ø§Ù†Ú©Ø§Ø±ÛŒ: Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ø¯Ù†ÛŒ Ú†Ø§Øª Ù„ÛØ±Û•ØŒ Ù„Û• Ø¯Û†Ø®ÛŒ setup**
        startChat(currentRoomCode); 

        const playerListHTML = room.players.map(p => {
            const isCreator = p.id === room.creatorId;
            const isMe = p.id === myPlayerId;
            const statusText = p.isReady ? T('ready') : T('waitingForName');
            const statusClass = p.isReady ? 'ready' : '';
            
            // Add remove button for creator, but not for themselves
            const removeButton = isRoomCreator && !isMe ? 
                `<button class="remove-btn" onclick="removePlayerFromRoom('${p.id}')">${T('remove')}</button>` : 
                '';
            
            return `
                <div class="lobby-player-item ${isCreator ? 'creator' : ''}">
                    <div class="flex items-center">
                        ${removeButton}
                        <span class="font-bold">${p.name || T('waitingForName')} ${isCreator ? `(${T('creator')})` : ''}</span>
                    </div>
                    <span class="status ${statusClass}">${statusText}</span>
                </div>
            `;
        }).join('');

        const isMinimumPlayers = room.players.length >= 3;
        const allPlayersReady = room.players.every(p => p.isReady && p.name);

        container.innerHTML = `
            <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
            <div class="title-bar mb-6"></div>
            
            <p id="room-code-label">${T('roomCode')}</p>
            <p id="room-code-display" onclick="copyRoomCode()">${room.code}</p>
            <p class="text-sm text-slate-400 text-center mb-6">${T('shareLink')}</p>
            
            <div class="flex justify-between items-center text-slate-300 mb-4">
                <p><strong>${T('myStatus')}</strong></p>
                <p class="status ${myStatusKey === 'ready' ? 'ready' : ''}">${T(myStatusKey)}</p>
            </div>
            
            <p class="text-slate-300 mb-2 text-right">${T('enterYourName')}</p>
            <div class="flex gap-2">
                <input type="text" id="my-name-input" placeholder="${T('playerName')}" value="${myPlayerName}" 
                       onfocus="isInputFocused = true" 
                       onblur="isInputFocused = false"
                       maxlength="15" 
                       class="flex-grow">
                <button class="primary-btn w-auto px-6 py-2" onclick="submitName()">
                    ${T('submit')}
                </button>
            </div>

            ${isRoomCreator ? `
                <div class="mt-4">
                    <p class="text-slate-300 mb-2 text-right">${T('imposterCount')}</p>
                    <input type="number" min="1" max="5" value="${room.imposterCount}" 
                           onchange="updateRoomSettings(this.value)" class="mb-4">
                </div>
            ` : `<p class="text-slate-400 text-sm mt-4 text-center">${T('imposterCount')}: ${room.imposterCount}</p>`}

            <div class="mt-6 mb-4 max-h-40 overflow-y-auto pr-1">
                ${playerListHTML}
            </div>

            <button class="primary-btn mt-4 ${!isMinimumPlayers || !allPlayersReady || !isRoomCreator ? 'opacity-50 cursor-not-allowed' : ''}" 
                    onclick="startRoomGame()" ${!isMinimumPlayers || !allPlayersReady || !isRoomCreator ? 'disabled' : ''}>
                ${T('roomStart')}
            </button>
            
            <button class="back-btn" onclick="exitRoom()">
                ${T('exitRoom')}
            </button>
            
            <div class="footer-text mt-8">
                ${T('madeBy')}
                <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a>
            </div>
        `;
    };
    
    const exitRoom = async () => {
        if (!currentRoomCode) {
            resetGame();
            return;
        }
        
        stopRoomPolling();
        stopChat(); 
        
        const room = await getRoomSnapshot(currentRoomCode);
        if (room) {
            const updatedPlayers = room.players.filter(p => p.id !== myPlayerId);
            
            if (updatedPlayers.length === 0) {
                await database.ref('rooms/' + currentRoomCode).remove();
            } else {
                let updates = { players: updatedPlayers };
                if (isRoomCreator && updatedPlayers.length > 0 && room.creatorId === myPlayerId) {
                    updates.creatorId = updatedPlayers[0].id;
                }
                await database.ref('rooms/' + currentRoomCode).update(updates);
            }
        }
        
        currentRoomCode = null;
        isRoomCreator = false;
        isRoomMode = false;
        isGameStartedInRoom = false;
        myPlayerId = null;
        isInputFocused = false; 
        myPlayerName = '';
        playerColorMap = {}; 
        
        hideModal(); 
        resetGame();
    };
    
    const resetGame = (skipRoomCheck = false) => {
        if (isRoomMode && isRoomCreator && !skipRoomCheck) {
            resetRoomGame();
            return;
        }
        
        gameActive = false;
        roles = [];
        secretWord = '';
        imposterHintWord = '';
        clearInterval(timerInterval);
        timerInterval = null;
        timeLeft = null;
        
        if (!isRoomMode || skipRoomCheck) {
            stopRoomPolling();
            stopChat();
            currentRoomCode = null;
            isRoomCreator = false;
            isRoomMode = false;
            isGameStartedInRoom = false;
            myPlayerId = null;
            myPlayerName = '';
            playerColorMap = {}; 
        }
        
        playerNames = Array(playerCount).fill('').map((_, i) => playerNames[i] || '');
        
        renderSetupView();
    };

    const checkUrlForRoom = () => {
         const urlParams = new URLSearchParams(window.location.search);
         const roomCode = urlParams.get('room');
         if (roomCode && roomCode.length === 4) {
             joinRoom(roomCode);
             window.history.replaceState({}, document.title, window.location.pathname);
         }
    };
    
    window.onload = () => {
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        database = firebase.database();
        
        // Initialize a second Firebase app for the chat database
        try {
            chatApp = firebase.initializeApp(chatFirebaseConfig, "chatApp");
            chatDatabase = chatApp.database();
        } catch (e) {
            console.warn("Chat Firebase App already initialized or failed to initialize:", e);
            chatApp = firebase.app("chatApp");
            chatDatabase = chatApp.database();
        }

         // --- NEW: Setup Online Presence ---
         setupOnlinePresence();
         // ----------------------------------

         if (playerNames.length === 0) {
             for (let i = 0; i < playerCount; i++) {
                playerNames.push('');
            }
        }
        renderSetupView();
        checkUrlForRoom();
    };
 </script>
</body>
</html>
