<!DOCTYPE html>
<html lang="ku" dir="rtl">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title id="main-title">ÛŒØ§Ø±ÛŒ ÙÛÚµØ¨Ø§Ø² (Imposter)</title>
 <script src="https://cdn.tailwindcss.com"></script>
 
 <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
 <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
 <script>
     tailwind.config = {
         theme: {
             extend: {
                 colors: {
                     'primary': '#facc15', // Tailwind Amber 500
                     'secondary': '#6366f1', // Tailwind Indigo 500
                     'dark-bg': '#1e293b', // Tailwind Slate 800
                     'dark-card': '#334155', // Tailwind Slate 700
                     'input-bg': '#475569', // Tailwind Slate 600
                 },
                 fontFamily: {
                     'kurdish': ['Scheherazade New', 'sans-serif'],
                     'english': ['Roboto', 'sans-serif'],
                 }
             }
         }
     }
 </script>
 <style>
     @import url('https://fonts.googleapis.com/css2?family=Scheherazade+New:wght@400;700&display=swap');
     @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap'); 

     body {
         background-color: #0f172a; /* Tailwind Slate 900 */
         background-image: radial-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), radial-gradient(rgba(255,255,255,0.05) 1px, transparent 1px);
         background-size: 40px 40px;
         background-position: 0 0, 20px 20px;
         display: flex;
         justify-content: center;
         align-items: center;
         min-height: 100vh;
         padding: 20px;
         font-family: 'kurdish', 'english';
     }

     .card {
         background-color: var(--dark-card);
         border-radius: 1.5rem;
         padding: 2.5rem 1.5rem;
         box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
         max-width: 420px;
         width: 100%;
         margin-top: 20px;
         margin-bottom: 20px;
     }

     .title-bar {
         border-bottom: 2px solid rgba(255, 255, 255, 0.1);
         padding-bottom: 0.75rem;
         margin-bottom: 1.5rem;
     }

     input[type="number"], input[type="text"], .input-text-area {
         background-color: var(--input-bg);
         color: #f8fafc;
         border: 1px solid #475569;
         border-radius: 0.5rem;
         padding: 0.5rem 0.75rem;
         width: 100%;
         margin-bottom: 0.75rem;
         text-align: right;
     }

     .english-mode input[type="number"], .english-mode input[type="text"], .english-mode .input-text-area {
          text-align: left;
     }

     .primary-btn {
         background: linear-gradient(145deg, #facc15, #eab308);
         color: #1e293b;
         font-weight: 700;
         padding: 0.75rem 1.5rem;
         border-radius: 0.75rem;
         box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(0, 0, 0, 0.15);
         transition: all 0.2s;
         width: 100%;
     }

     .primary-btn:hover {
         opacity: 0.9;
         transform: translateY(-1px);
         box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.2);
     }
     
     .secondary-btn {
        background: linear-gradient(145deg, #6366f1, #4f46e5);
        color: white;
        font-weight: 700;
        padding: 0.75rem 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(0, 0, 0, 0.15);
        transition: all 0.2s;
        width: 100%;
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
     }

     .secondary-btn:hover {
         opacity: 0.9;
         transform: translateY(-1px);
         box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.2);
     }
     
     .back-btn {
         background-color: transparent;
         border: 2px solid #94a3b8;
         color: #94a3b8;
         font-weight: 500;
         padding: 0.5rem 1rem;
         border-radius: 0.5rem;
         transition: all 0.2s;
         width: 100%;
         margin-top: 1rem;
     }
     .back-btn:hover {
        background-color: #334155;
        color: #f8fafc;
     }
     
     .lobby-player-item {
         display: flex;
         justify-content: space-between;
         align-items: center;
         background-color: #475569;
         padding: 0.5rem 1rem;
         border-radius: 0.5rem;
         margin-bottom: 0.5rem;
         color: #f8fafc;
         font-size: 1rem;
     }
     .lobby-player-item.creator {
         border: 2px solid #facc15;
     }
     .lobby-player-item .status {
         font-size: 0.875rem;
         color: #94a3b8;
     }
     .lobby-player-item .status.ready {
         color: #34d399;
         font-weight: 700;
     }

     .player-card {
         background-color: #475569;
         border: 1px solid #64748b;
         padding: 20px;
         border-radius: 1rem;
         margin-top: 1.5rem;
         text-align: center;
         box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
         transition: all 0.3s;
     }
   
     .player-card:hover {
         transform: scale(1.02);
     }

     .word-civilian {
         color: #34d399;
     }
     .word-imposter {
         color: #f87171;
     }

     .role-text {
         font-size: 1.5rem;
         font-weight: 700;
         color: var(--primary);
         margin-bottom: 10px;
     }
     /* UPDATED: Simplify role text display */
     .role-text-simplified {
         font-size: 2rem;
         font-weight: 700;
         margin-bottom: 0;
     }

     .word-text {
         font-size: 1.25rem;
         color: #f8fafc;
     }
   
     .lang-btn {
         background-color: var(--secondary);
         color: #f8fafc;
         padding: 0.5rem 1rem;
         border-radius: 0.5rem;
         font-size: 0.875rem;
         transition: background-color 0.2s;
         margin-bottom: 1.5rem;
     }
     .lang-btn:hover {
         background-color: #4f46e5;
     }

     .footer-text {
         margin-top: 2rem;
         text-align: center;
         font-size: 0.8rem;
         color: #94a3b8;
     }
   
     .footer-text a {
         color: var(--primary);
         text-decoration: none;
         margin-right: 5px;
         margin-left: 5px;
     }
     .footer-text a:hover {
         text-decoration: underline;
     }

     #custom-modal {
         position: fixed;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         background-color: rgba(0, 0, 0, 0.7);
         display: flex;
         justify-content: center;
         align-items: center;
         z-index: 1000;
         opacity: 0;
         visibility: hidden;
         transition: opacity 0.3s, visibility 0.3s;
         overflow-y: auto;
     }
     #custom-modal.show {
         opacity: 1;
         visibility: visible;
     }
     .modal-content {
         background-color: var(--dark-card);
         margin: 5% auto; 
         padding: 2rem;
         border-radius: 1rem;
         max-width: 350px;
         width: 90%;
         color: #f8fafc;
         text-align: center;
         box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
         transform: translateY(-50px);
         transition: transform 0.3s;
         max-height: 90vh;
         overflow-y: auto;
         position: relative;
     }
     #custom-modal.show .modal-content {
         transform: translateY(0);
     }
     .modal-title {
         font-size: 1.5rem;
         font-weight: 700;
         color: #facc15;
         margin-bottom: 0.75rem;
     }
     .imposter-popup .modal-title {
        color: #f87171;
        font-size: 2rem;
     }
     .imposter-popup .modal-message {
        font-size: 1.5rem;
        font-weight: bold;
        color: #facc15;
     }
     .modal-message {
         margin-bottom: 1.5rem;
         font-size: 1rem;
         text-align: right;
     }
     .ltr .modal-message {
         text-align: left;
     }
     .modal-message strong {
         color: #facc15;
     }
     
     .modal-close-btn {
        position: absolute;
        top: 10px;
        right: 10px; 
        font-size: 1.5rem;
        background: none;
        border: none;
        color: #f8fafc;
        cursor: pointer;
        line-height: 1;
        padding: 5px;
     }
     .rtl .modal-close-btn {
        right: 10px;
        left: auto;
     }
     .ltr .modal-close-btn {
        left: 10px;
        right: auto;
     }
     
     #room-code-display {
         font-family: 'Roboto', monospace;
         font-size: 2.5rem;
         font-weight: 900;
         color: #facc15;
         letter-spacing: 0.2rem;
         margin: 1rem 0;
         text-align: center;
         user-select: all;
     }
     #room-code-label {
         color: #94a3b8;
         font-weight: 700;
         font-size: 1.1rem;
     }
     
     .share-button {
         position: fixed;
         bottom: 20px;
         left: 20px;
         background-color: var(--secondary);
         color: white;
         border: none;
         border-radius: 50%;
         width: 50px;
         height: 50px;
         display: flex;
         align-items: center;
         justify-content: center;
         cursor: pointer;
         box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
         z-index: 1000;
         transition: background-color 0.2s, transform 0.2s;
     }
     .share-button:hover {
         background-color: #4f46e5;
         transform: scale(1.05);
     }
     .rtl .share-button {
         left: auto;
         right: 20px;
     }
     .ltr .share-button {
         right: auto;
         left: 20px;
     }

     .help-button {
         position: fixed;
         bottom: 20px;
         background-color: #34d399;
         color: #1e293b;
         border: none;
         border-radius: 50%;
         width: 50px;
         height: 50px;
         font-size: 1.5rem;
         font-weight: bold;
         display: flex;
         align-items: center;
         justify-content: center;
         cursor: pointer;
         box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
         z-index: 1000;
         transition: background-color 0.2s, transform 0.2s;
     }
     .help-button:hover {
         background-color: #10b981;
         transform: scale(1.05);
     }
     .rtl .help-button {
         right: 90px;
         left: auto;
     }
     .ltr .help-button {
         left: 90px;
         right: auto;
     }
 </style>
</head>
<body class="rtl" style="--dark-card: #334155; --input-bg: #475569; --primary: #facc15; --secondary: #6366f1;">

 <div id="game-container" class="card">
     </div>

 <div id="custom-modal">
     <div class="modal-content" id="modal-inner">
         </div>
 </div>

 <button id="shareButton" class="share-button" onclick="shareGameLink()">
     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-share-2"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>
 </button>

 <button id="helpButton" class="help-button" onclick="showHelpModal()">
    ?
 </button>


 <script>
    const firebaseConfig = {
        apiKey: "YOUR_API_KEY", 
        authDomain: "kigbynaseh.firebaseapp.com",
        databaseURL: "https://kigbynaseh-default-rtdb.firebaseio.com",
        projectId: "kigbynaseh",
        storageBucket: "kigbynaseh.appspot.com",
        messagingSenderId: "YOUR_SENDER_ID",
        appId: "YOUR_APP_ID"
    };

    // Global state for modal
    const modal = document.getElementById('custom-modal');
    const modalInner = document.getElementById('modal-inner');
    const shareButton = document.getElementById('shareButton');
    const helpButton = document.getElementById('helpButton');

    // FIREBASE STATE
    let database;
    let roomRef; // Reference to the current room in the database
    let myPlayerId = null; // Unique ID for this player session

    // --- Data: Word Lists (Unchanged) ---
    const WORDS_KU = [
        "Ù¾Ø²ÛŒØ´Ú©", "Ù…Ø§Ù…Û†Ø³ØªØ§", "Ø¦Û•Ù†Ø¯Ø§Ø²ÛŒØ§Ø±", "ÙÛ•Ø±Ù…Ø§Ù†Ø¨Û•Ø±", "Ø´Û†ÙÛØ±", "Ú¯Û†Ø±Ø§Ù†ÛŒØ¨ÛÚ˜", "Ù†ÙˆÙˆØ³Û•Ø±", "ÙˆÛ•Ø±Ú¯ÛÚ•",
        "Ú©Ø§Ø³Ø¨Ú©Ø§Ø±", "ÙˆÛÙ†Û•Ú©ÛØ´", "Ø¨Ø§Ø®Ú†Û•ÙˆØ§Ù†", "Ù†Ø§Ù†Û•ÙˆØ§", "Ú¯Û•Ø´ØªÛŒØ§Ø±", "ÙˆÛ•Ø±Ø²Ø´Ú©Ø§Ø±", "ÙØ±Û†Ø´ÛŒØ§Ø±", "Ù¾Û†Ù„ÛŒØ³",
        "Ø³Û•Ø±Ø¨Ø§Ø²", "Ø¦Ø§Ú¯Ø±Ú©ÙˆÚ˜ÛÙ†Û•Ø±", "Ø¨Ø§Ø²Ø±Ú¯Ø§Ù†", "Ú•Û†Ú˜Ù†Ø§Ù…Û•Ù†ÙˆÙˆØ³", "Ø¬ÙˆÙˆØªÛŒØ§Ø±", "Ù¾Ø§Ø³Û•ÙˆØ§Ù†", "Ù‚Û•Ø´Û•", "Ú•Ø§ÙˆÚ†ÛŒ", "Ø´ÙˆØ§Ù†", 
        "Ø³Û•Ú¯", "Ù¾Ø´ÛŒÙ„Û•", "Ø¦Ø§Ú˜Û•Úµ", "ÙˆØ±Ú†", "Ú¯ÙˆØ±Ú¯", "Ø¦Ø§Ø³Ú©", "Ú•ÛÙˆÛŒ", "Ø´ÛØ±", "Ù†Û•Ù‡Û•Ù†Ú¯", "Ø¦Û•Ø³Ù¾", "Ø´Û•Ù…Ø´Û•Ù…Û•Ú©ÙˆÛØ±Û•",
        "Ø³Ù…Û†Ø±Û•", "ÙÛŒÙ„", "Ù…Û•ÛŒÙ…ÙˆÙˆÙ†", "Ú†ÛŒÙ…Ù¾Ø§Ù†Ø²ÛŒ", "Ù‡Û•ÚµÛ†", "Ú©ÙˆÙ†Ø¯Û•Ù¾Û•Ù¾ÙˆÙˆ", "Ù‚Û•Ù„Û•Ú•Û•Ø´", "ØªÙˆÙˆØªÛŒ", "Ù…Ø±ÛŒØ´Ú©", "Ù‚Ø§Ø²", "Ù…Û•Ù„",
        "Ù…Ø§Ø±", "Ù…Ø§Ø±Ù…ÛÙ„Ú©Û•", "Ù‚Û•Ù„", "Ú©ÛŒØ³Û•Úµ", "ØªÙ…Ø³Ø§Ø­", "Ø¨Û†Ù‚", "Ù…Ø§Ø³ÛŒ", "Ù‚Ø±Ø´", "Ø¦Û•Ø®ØªÛ•Ø¨ÙˆØª", "Ø³ÛÙ„", "Ø¯Û†Ù„ÙÛŒÙ†", 
        "Ø¬Ø§ÚµØ¬Ø§ÚµÛ†Ú©Û•", "Ù…ÛØ±ÙˆÙ„Û•", "Ù‡Û•Ù†Ú¯", "Ù¾Û•Ù¾ÙˆÙˆÙ„Û•", "Ú©ÙˆÙˆÙ„Û•", "Ø¯ÙˆÙˆÙ¾Ø´Ú©", "Ù…Ø´Ú©", "Ø´ÛŒØ±ÛŒÙ†Û•Ù…", "Ù¾ÚµÙ†Ú¯", "Ú©Û•Ø±Ú©Û•Ø¯Û•Ù†",
        "Ø¯Ø§Ø±", "Ú¯ÙˆÚµ", "Ø³Û•ÙˆØ²Ø§ÛŒÛŒ", "Ù…ÛŒÙˆÛ•", "Ø³Û•ÙˆØ²Û•", "Ø¯Ø§Ø±Ø¨ÚµØ§ÚµÙˆÙˆÚ©", "Ø³Ù†Û•ÙˆØ¨Û•Ø±", "Ø¨ÛŒ", "Ù„Û•Ù¾", "Ú•Û•Ú¯", "ØªÛ•Ù†Û•", 
        "Ù„Ù‚", "Ú¯Û•ÚµØ§", "ØªÛ•Ù…Ø§ØªÛ•", "Ø®Û•ÛŒØ§Ø±", "Ù¾ÛŒØ§Ø²", "Ø³ÛŒØ±", "Ù‚Ø§Ø±Ú†Ú©", "Ù…Û†Ø³", "ÙÛ•Ú•Ù†", "ØªÙˆÙˆ", "Ú¯Ú˜ÙˆÚ¯ÛŒØ§", "Ú¯Û•Ù†Ù…", "Ú¯Û•Ù†Ù…Û•Ø´Ø§Ù…ÛŒ",
        "Ú¯ÛŒØ±Ø§ÙˆÛ•", "Ù‡Ø§ÚµØ§Ø²", "Ù¾Û•ØªØ§ØªÛ•", "Ú†Ø§ÛŒ", "Ù‚Ø§ÙˆÛ•", "Ø´ÛŒØ±", "Ù‡Û•Ù†Ú¯ÙˆÛŒÙ†", "Ø²Û•ÛŒØªÙˆÙˆÙ†", "Ú¯Û•Ø²Û†", "Ø³Ø±ÙˆØ´Øª", 
        "Ú†ÛŒØ§", "Ø¯Û•Ø´Øª", "Ø¯Û•Ø±ÛŒØ§", "Ú¯ÙˆÙ†Ø¯", "Ø´Ø§Ø±", "Ù…Ø§Úµ", "Ù‚ÙˆØªØ§Ø¨Ø®Ø§Ù†Û•", "Ø²Ø§Ù†Ú©Û†", "Ú©Ø§Ø±Ú¯Û•", "Ù…Û†Ø²Û•Ø®Ø§Ù†Û•", "Ø´Ø§Ù†Û†",
        "Ø³ÛŒÙ†Û•Ù…Ø§", "Ù…Ø²Ú¯Û•ÙˆØª", "Ú©ÚµÛØ³Ø§", "Ù¾Û•Ø±Ø³ØªÚ¯Ø§", "Ù‚Û•ÚµØ§", "Ø´Û•Ù‚Ø§Ù…", "Ø¨ÛŒØ§Ø¨Ø§Ù†", "Ø²Û†Ù†Ú¯Ø§Ùˆ", "Ø¯Ø§Ø±Ø³ØªØ§Ù†", "Ú©Ø§Ù†ÛŒ",
        "Ø¦Û†ØªÛ†Ù…Ø¨ÛÙ„", "ÙÚ•Û†Ú©Û•", "Ø´Û•Ù…Û•Ù†Ø¯Û•ÙÛ•Ø±", "Ù¾Ø§Ø³Ú©ÛŒÙ„", "Ú©Û†Ù…Û•ÚµÚ¯Ø§", "Ø®ÛØ²Ø§Ù†", "Ù‡Ø§ÙˆÚ•Û", "Ø¯Ø±Ø§ÙˆØ³Û", "Ú©Û†Ù…Û•ÚµÛ•",
        "Ú©Û•Ù…Ù¾ÛŒ Ù¾Û•Ù†Ø§Ø¨Û•Ø±Ø§Ù†", "Ù†Ø§ÙˆÚ†Û•", "Ø´Ø§Ø±Û†Ú†Ú©Û•", "Ù¾Ø§ÛŒØªÛ•Ø®Øª", "Ú¯Û•Ø±Ø§Ø¬", "Ø¨Ø§Ø²Ø§Ú•", "Ø¯ÙˆÚ©Ø§Ù†", "Ù‚Ø§ÙˆÛ•Ø®Ø§Ù†Û•", "Ú©ØªÛØ¨ÙØ±Û†Ø´",
        "Ù‚Û•Ø±Ø§Øº Ø¯Û•Ø±ÛŒØ§", "Ú¯Û•Ø±ÙˆÙˆ", "ØªØ§Ú¤Ú¯Û•", "Ø¯ÙˆÙˆØ±Ú¯Û•", "Ú¯Ú•Ú©Ø§Ù†", "Ú¯Û•Ù†Ø¬ÛŒÙ†Û•", "Ø³Ù†ÙˆÙˆØ±", "Ø¨Û•Ø±Ù†Ø§Ù…Û•", "Ù…Ø§ÚµÙ¾Û•Ú•",
        "Ø®Û†Ø±Ø§Ú©", "Ø¦Ø§Ùˆ", "Ù‡Û•ÙˆØ±", "Ø¨Ø§Ø±Ø§Ù†", "Ø¨Û•ÙØ±", "Ù‡Û•ØªØ§Ùˆ", "Ù…Ø§Ù†Ú¯", "Ø¦Û•Ø³ØªÛØ±Û•", "Ú©ØªÛØ¨", "Ù‚Û•ÚµÛ•Ù…", "Ù„Ø§Ù¾Û•Ú•Û•",
        "Ù…Û†Ø¨Ø§ÛŒÙ„", "Ú©Û†Ù…Ù¾ÛŒÙˆØªÛ•Ø±", "Ù…Û†Ø³ÛŒÙ‚Ø§", "Ø´ÛØ¹Ø±", "Ú•Û†Ù…Ø§Ù†", "Ú†ÛŒØ±Û†Ú©", "Ú•Û•Ù†Ú¯", "Ø¯Û•Ù†Ú¯", "Ø¨Û†Ù†", "ØªØ§Ù…ÛŒ", "Ú•ÙˆÙˆÙ†Ø§Ú©ÛŒ",
        "ØªØ§Ø±ÛŒÚ©ÛŒ", "Ú¯Ø§Ø²", "Ù¾Û•ØªÚ•Û†Úµ", "Ú©Ø§Ø±Û•Ø¨Ø§", "Ù…Û•ØªØ±Ø³ÛŒ", "Ø¦Ø§Ø³Ø§ÛŒØ´", "Ø¯Ø§Ø¯Ú¯Ø§", "ÛŒØ§Ø³Ø§", "Ø³ÛŒØ§Ø³Û•Øª", "Ø¦Ø§Ø¨ÙˆÙˆØ±ÛŒ", 
        "ÙÛ•Ù„Ø³Û•ÙÛ•", "Ù…ÛÚ˜ÙˆÙˆ", "Ø¬ÙˆÚ¯Ø±Ø§ÙÛŒØ§", "ÙÛŒØ²ÛŒÚ©", "Ú©ÛŒÙ…ÛŒØ§", "Ø¨ÛŒØ±Ú©Ø§Ø±ÛŒ", "Ù¾Û•Ø±ÙˆÛ•Ø±Ø¯Û•", "ØªÛ•Ù†Ø¯Ø±ÙˆØ³ØªÛŒ", "Ú˜ÛŒÙ†Ú¯Û•",
        "Ù…Ø§ÙÛŒ Ù…Ø±Û†Ú¤", "Ø¦Ø§Ø²Ø§Ø¯ÛŒ", "ÛŒÛ•Ú©Ø³Ø§Ù†ÛŒ", "Ø®Û•ÙˆÙ†", "Ú•Ø§Ø³ØªÛŒ", "Ø®Û†Ø´Û•ÙˆÛŒØ³ØªÛŒ", "Ú•Ù‚", "ØªØ±Ø³", "Ù‡ÛŒÙˆØ§", "Ø¦Ø§Ø±Ø§Ù…ÛŒ", 
        "Ø´Û•Ú•", "Ø¦Ø§Ø´ØªÛŒ", "Ø´ÛŒØ±ÛŒÙ†ÛŒ", "Ø³ÙˆÛØ±ÛŒ", "ØªØ§ÚµÛŒ", "ØªÛŒÚ˜ÛŒ", "Ø®ÙˆÛÙ†", "Ù…ÛØ´Ú©", "Ø¯Úµ", "Ú¯Û•Ø¯Û•", "Ú†Ø§Ùˆ", "Ú¯ÙˆÛ", "Ø¯Û•Ø³Øª", 
        "Ù‚Ø§Ú†", "Ù¾ÛØ³Øª", "Ù…ÙˆÙˆ", "Ø¬Ù„ÙˆØ¨Û•Ø±Ú¯", "Ø³ÙØ±Û•", "Ù…Ø§ØªÛ†Ø±", "ØªÛ•Ù„Ø¨Û•Ù†Ø¯", "ÙÛŒØ´Û•Ú©", "Ø¨Û†Ù…Ø¨", "Ú•Û†Ú©ÛØª", "Ù†Ø§ÙˆÚ†Û•", 
        "ØªÛ•Ø®ØªÛ•", "Ù‚ÙˆÙ…Ø§Ø´", "Ø¬Ø§Ù…", "Ø²Û•Ù„Ú©Ø§Ùˆ", "Ø¯Û•Ù…Ø§Ù†Ú†Û•", "ØªÛ•Ù‚ÛŒÙ†Û•ÙˆÛ•", "Ø¨Û•ÚµÚ¯Û•Ù†Ø§Ù…Û•", "ØªØ§ÙˆØ§Ù†", "Ú©Ù„ÛŒÙ„", "Ø³Ù†Ø¯ÙˆÙ‚",
        "Ú˜Ù…Ø§Ø±Û•", "Ù¾ÛŒØª", "ÙˆØ´Û•", "Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ø¯Ù†", "Ø®Ø§Ú©", "Ú¯Ø´Øª", "Ú©Ø´ØªÙˆÚ©Ø§Úµ", "Ú©Ø§Ø¨ÛŒÙ†Û•", "Ù…Û†Ù…", "Ø¦Ø§Ù…ÛØ±", "ÙˆÚµØ§Øª", "Ù¾Ø§Ø±ØªÛŒ"
    ];
   
    const WORDS_EN = [
        "Doctor", "Teacher", "Engineer", "Employee", "Driver", "Singer", "Writer", "Translator",
        "Merchant", "Painter", "Gardener", "Baker", "Tourist", "Athlete", "Seller", "Police",
        "Soldier", "Firefighter", "Trader", "Journalist", "Farmer", "Guard", "Priest", "Hunter", "Shepherd", 
        "Dog", "Cat", "Animal", "Bear", "Wolf", "Deer", "Fox", "Lion", "Whale", "Horse", "Bat", "Squirrel",
        "Elephant", "Monkey", "Chimpanzee", "Eagle", "Owl", "Raven", "Parrot", "Chicken", "Goose", "Bird",
        "Snake", "Lizard", "Frog", "Turtle", "Alligator", "Toad", "Fish", "Shark", "Octopus", "Seal", "Dolphin", 
        "Spider", "Ant", "Bee", "Butterfly", "Moth", "Scorpion", "Mouse", "Cheetah", "Rhinoceros",
        "Tree", "Flower", "Greenery", "Fruit", "Vegetable", "Oak", "Pine", "Willow", "Birch", "Palm", "Root", "Trunk", 
        "Branch", "Leaf", "Tomato", "Cucumber", "Onion", "Garlic", "Mushroom", "Moss", "Fern", "Berry", "Herb", "Grass", 
        "Wheat", "Corn", "Vine", "Algae", "Potato", "Tea", "Coffee", "Milk", "Honey", "Olive", "Nature",
        "Mountain", "Plain", "Sea", "Village", "City", "House", "School", "University", "Factory", "Museum", "Theater", 
        "Cinema", "Mosque", "Church", "Temple", "Castle", "Street", "Desert", "Swamp", "Forest", "River", 
        "Car", "Airplane", "Train", "Bicycle", "Society", "Family", "Friend", "Neighbor", "Group",
        "Refugee Camp", "Area", "Town", "Capital City", "Garage", "Market", "Shop", "Coffee Shop", "Bookstore",
        "Coast", "Canyon", "Waterfall", "Island", "Volcano", "Treasure", "Border", "Program", "Website",
        "Food", "Water", "Cloud", "Rain", "Snow", "Sun", "Moon", "Star", "Book", "Pen", "Page",
        "Mobile", "Computer", "Music", "Poem", "Novel", "Story", "Color", "Sound", "Smell", "Taste", "Light",
        "Darkness", "Gas", "Petrol", "Electricity", "Danger", "Safety", "Court", "Law", "Politics", "Economy", 
        "Philosophy", "History", "Geography", "Physics", "Chemistry", "Mathematics", "Education", "Health", 
        "Environment", "Human Rights", "Freedom", "Equality", "Dream", "Reality", "Love", "Hate",
        "Fear", "Hope", "Peace", "War", "Sweet", "Salty", "Bitter", "Spicy", "Blood", "Brain", "Heart", 
        "Stomach", "Eye", "Ear", "Hand", "Leg", "Skin", "Hair", "Clothing", "Tablecloth", "Motorcycle", "Fence", 
        "Bullet", "Bomb", "Rocket", "Region", "Board (Wood)", "Cloth", "Glass", "Marsh", "Pistol", "Explosion",
        "Document", "Crime", "Key", "Box", "Number", "Letter (Alphabet)", "Word", "Creation", "Soil", "Total", 
        "Agriculture", "Cabinet (Government)", "Candle", "Device", "Country", "Party"
    ];


    // --- State Variables (UPDATED) ---
    let lang = 'ku';
    let playerCount = 4;
    let imposterCount = 1;
    let playerNames = [];
    let gameActive = false;
    let roles = [];
    let secretWord = '';
    let imposterHintWord = '';

    let isRoomMode = false;
    let currentRoomCode = null;
    let isRoomCreator = false;
    let isGameStartedInRoom = false;
    let isInputFocused = false; 

    let timerInterval;
    let timeLeft;


    // --- Helper Functions (Translation & UI remain mostly the same) ---
    const getWordList = () => lang === 'ku' ? WORDS_KU : WORDS_EN;

    const T = (key, l = lang) => {
        const translations = {
            ku: {
                appName: "ÛŒØ§Ø±ÛŒ ÙÛÚµØ¨Ø§Ø²", imposter: "ÙÛÚµØ¨Ø§Ø²", civilian: "Ù‡Ø§ÙˆÚµØ§ØªÛŒ", playerCount: "Ú˜Ù…Ø§Ø±Û•ÛŒ ÛŒØ§Ø±ÛŒØ²Ø§Ù†Ø§Ù† (3-12):", imposterCount: "Ú˜Ù…Ø§Ø±Û•ÛŒ ÙÛÚµØ¨Ø§Ø²Û•Ú©Ø§Ù† (1-2):", start: "Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ø¯Ù†ÛŒ ÛŒØ§Ø±ÛŒ", playerName: "Ù†Ø§ÙˆÛŒ ÛŒØ§Ø±ÛŒØ²Ø§Ù†", showRole: "Ú•Û†ÚµÛŒ Ø®Û†Øª Ø¨Ø¨ÛŒÙ†Û•", yourRole: "Ú•Û†ÚµÛŒ ØªÛ†:", theWord: "ÙˆØ´Û•ÛŒ Ù†Ù‡ÛÙ†ÛŒ:", madeBy: "Made By Naseh M. Zebari", turn: "Ù†Û†Ø±Û•ÛŒ ÛŒØ§Ø±ÛŒØ²Ø§Ù†Ø§Ù†", close: "Ø¯Ø§Ø®Ø³ØªÙ†", reset: "Ø¯ÙˆÙˆØ¨Ø§Ø±Û• Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ø¯Ù†Û•ÙˆÛ•", revealWord: "ÙˆØ´Û•ÛŒ Ù†Ù‡ÛÙ†ÛŒ Ù†ÛŒØ´Ø§Ù† Ø¨Ø¯Û• (Ø¨Û† Ù‡Û•Ù…ÙˆÙˆØ§Ù†)", wordWas: "ÙˆØ´Û•ÛŒ Ù†Ù‡ÛÙ†ÛŒ Ø¨Ø±ÛŒØªÛŒ Ø¨ÙˆÙˆ Ù„Û•:", selectWord: "ØªÚ©Ø§ÛŒÛ• ÙˆØ´Û•ÛŒ Ù†Ù‡ÛÙ†ÛŒ Ù‡Û•ÚµØ¨Ú˜ÛØ±Û•!", validationTitle: "Ù‡Û†Ø´Ø¯Ø§Ø±ÛŒ", nameRequired: "ØªÚ©Ø§ÛŒÛ• Ù†Ø§ÙˆÛŒ Ù‡Û•Ù…ÙˆÙˆ ÛŒØ§Ø±ÛŒØ²Ø§Ù†Û•Ú©Ø§Ù† Ø¨Ù†ÙˆÙˆØ³Û•.", notEnoughPlayers: "Ú˜Ù…Ø§Ø±Û•ÛŒ ÛŒØ§Ø±ÛŒØ²Ø§Ù†Ø§Ù† Ú©Û•Ù…Û•. Ù¾ÛÙˆÛŒØ³ØªØª Ø¨Û• Ù„Ø§Ù†ÛŒ Ú©Û•Ù… 3 ÛŒØ§Ø±ÛŒØ²Ø§Ù†Û•.", revealImposters: "ÙÛÚµØ¨Ø§Ø²Û•Ú©Ø§Ù† Ù†ÛŒØ´Ø§Ù† Ø¨Ø¯Û•", impostersWere: "ÙÛÚµØ¨Ø§Ø²Û•Ú©Ø§Ù† Ø¨Ø±ÛŒØªÛŒ Ø¨ÙˆÙˆÙ† Ù„Û•:", justImposter: "ØªÛ† ÙÛÚµØ¨Ø§Ø²ÛŒ!", imposterHintLabel: "ÙˆØ´Û•:", startDiscussion: "Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ø¯Ù†ÛŒ Ú¯ÙØªÙˆÚ¯Û†", discussionTime: "Ú©Ø§ØªÛŒ Ú¯ÙØªÙˆÚ¯Û†:", timesUp: "Ú©Ø§Øª Ú©Û†ØªØ§ÛŒÛŒ Ù‡Ø§Øª!", imposterWas: "ÙÛÚµØ¨Ø§Ø²Û•Ú©Û• Ø¨Ø±ÛŒØªÛŒ Ø¨ÙˆÙˆ Ù„Û•:", shareLink: "Ù„ÛŒÙ†Ú©ÛŒ ÛŒØ§Ø±ÛŒÛŒÛ•Ú©Û• Ø¨Ù†ÛØ±Û• Ø¨Û† Ù‡Ø§ÙˆÚ•ÛÚ©Ø§Ù†Øª!", and: "Ùˆ", howToPlayTitle: "Ú†Û†Ù† ÛŒØ§Ø±ÛŒ Ø¯Û•Ú©Û•ÛŒØª: ÛŒØ§Ø±ÛŒ ÙÛÚµØ¨Ø§Ø²", howToPlayBody: `Ø¦Ø§Ù…Ø§Ù†Ø¬ Ø¦Û•ÙˆÛ•ÛŒÛ• Ù‡Û•Ù…ÙˆÙˆØ§Ù† Ù‚Û•Ù†Ø§Ø¹Û•Øª Ù¾ÛØ¨Ú©Û•ÛŒØª Ú©Û• ÙˆØ´Û•ÛŒ Ù†Ù‡ÛÙ†ÛŒ Ø¯Û•Ø²Ø§Ù†ÛŒØªâ€”ÛŒØ§Ø®ÙˆØ¯ Ø¦Û•Ùˆ Ú©Û•Ø³Û• Ø¨Ø¯Û†Ø²ÛŒØªÛ•ÙˆÛ• Ú©Û• Ù†Ø§ÛŒØ²Ø§Ù†ÛØª.<br><br><strong>Ù¡. ğŸ¤« Ú•Û†ÚµÛŒ Ø®Û†Øª Ø¨Ø¯Û†Ø²Û•Ø±Û•ÙˆÛ•</strong><br>â€¢ Ù…Û†Ø¨Ø§ÛŒÙ„Û•Ú©Û• Ø¨Û•Ø¯Û•ÙˆØ±Ø¯Ø§ Ø¯Û•Ø³ÙˆÚ•ÛÙ†Ø±ÛØªÛ•ÙˆÛ• Ø¨Û† Ø¦Û•ÙˆÛ•ÛŒ Ù‡Û•Ù…ÙˆÙˆØ§Ù† Ø¨Û• Ù†Ù‡ÛÙ†ÛŒ Ø³Û•ÛŒØ±ÛŒ Ø´Ø§Ø´Û•Ú©Û• Ø¨Ú©Û•Ù†.<br>â€¢ Ø²Û†Ø±Ø¨Û•ÛŒ ÛŒØ§Ø±ÛŒØ²Ø§Ù†Û•Ú©Ø§Ù† <strong>ÙˆØ´Û•ÛŒ Ù†Ù‡ÛÙ†ÛŒ</strong> Ø¯Û•Ø¨ÛŒÙ†Ù† (Ø¨Û† Ù†Ù…ÙˆÙˆÙ†Û•: Ù‚Û•Ù†Û•ÙÛ•).<br>â€¢ ÛŒÛ•Ú© ÛŒØ§Ø±ÛŒØ²Ø§Ù† <strong>"ÙØ±ÛŒÙˆØ¯Û•Ø±"</strong> Ø¯Û•Ø¨ÛŒÙ†ÛØª.<br><br><strong>Ù¢. ğŸ—£ï¸ Ø¦Ø§Ù…Ø§Ú˜Û• Ø¨Ø¯Û•</strong><br>â€¢ Ø¨Û• Ø¯Û•ÙˆØ±ÛŒ Ø¨Ø§Ø²Ù†Û•Ú©Û•Ø¯Ø§ Ø¨Ú¯Û•Ú•ÛÙ†. Ù‡Û•Ø± ÛŒØ§Ø±ÛŒØ²Ø§Ù†ÛÚ© <strong>ÛŒÛ•Ú© ÙˆØ´Û•</strong> Ø¨Û† ÙˆÛ•Ø³ÙÚ©Ø±Ø¯Ù†ÛŒ ÙˆØ´Û• Ù†Ù‡ÛÙ†ÛŒÛŒÛ•Ú©Û• Ø¯Û•Ø¯Ø§Øª.<br>â€¢ <strong>Ø¦Û•Ú¯Û•Ø± ÙˆØ´Û•Ú©Û• Ø¯Û•Ø²Ø§Ù†ÛŒØª:</strong> Ø¦Ø§Ù…Ø§Ú˜Û•Ú©Û•Øª Ø¯Û•Ø¨ÛØª Ø¦Û•ÙˆÛ•Ù†Ø¯Û• Ø¯ÛŒØ§Ø±ÛŒÚ©Ø±Ø§Ùˆ Ø¨ÛØª Ú©Û• Ø¨ÛŒØ³Û•Ù„Ù…ÛÙ†ÛØª Ø¯Û•ÛŒØ²Ø§Ù†ÛŒØªØŒ Ø¨Û•ÚµØ§Ù… Ø¦Û•ÙˆÛ•Ù†Ø¯Û•Ø´ Ù†Ø§Ú•ÙˆÙˆÙ† Ø¨ÛØª Ú©Û• ÙÛÚµØ¨Ø§Ø²Û•Ú©Û• Ø³Û•Ø±Ù„ÛØ´ÛÙˆØ§Ùˆ Ø¨Ú©Ø§Øª.<br>â€¢ <strong>Ø¦Û•Ú¯Û•Ø± ØªÛ† ÙÛÚµØ¨Ø§Ø²ÛŒØª:</strong> Ø¦Ø§Ù…Ø§Ú˜Û•ÛŒÛ•Ú©ÛŒ Ú¯Ø´ØªÛŒ Ø¨Ø¯Û• Ú©Û• Ù„Û•Ú¯Û•Úµ Ù¾Û†Ù„Û•Ú©Û•Ø¯Ø§ Ø¨Ú¯ÙˆÙ†Ø¬ÛØª (Ø¨Û† Ù†Ù…ÙˆÙˆÙ†Û•: Ú©Û•Ù„ÙˆÙ¾Û•Ù„) Ùˆ Ù‡Û•ÙˆÚµØ¨Ø¯Û• ØªÛÚ©Û•Úµ Ø¨Ø¨ÛŒØª!<br><br><strong>Ù£. ğŸ—³ï¸ Ø¯Û•Ù†Ú¯Ø¯Ø§Ù†</strong><br>â€¢ Ø¯ÙˆØ§ÛŒ Ù¢-Ù£ Ú¯Û•Ú•ÛŒ Ø¦Ø§Ù…Ø§Ú˜Û•Ø¯Ø§Ù†ØŒ Ú¯ÙØªÙˆÚ¯Û† Ø¯Û•Ø³ØªÙ¾ÛØ¯Û•Ú©Ø§Øª. ØªÛ†Ù…Û•Øª Ø¨Ø®Û•Ø±Û• Ù¾Ø§Úµ Ø¦Û•Ùˆ ÛŒØ§Ø±ÛŒØ²Ø§Ù†Û•ÛŒ Ú©Û• Ø¦Ø§Ù…Ø§Ú˜Û•Ú©Ø§Ù†ÛŒ Ú¯ÙˆÙ…Ø§Ù†Ø§ÙˆÛŒØªØ±ÛŒÙ† ÛŒØ§Ù† Ú¯Ø´ØªÛŒØªØ±ÛŒÙ† Ø¨ÙˆÙˆÙ†.<br>â€¢ Ù‡Û•Ù…ÙˆÙˆØ§Ù† Ø¯Û•Ù†Ú¯ Ø¯Û•Ø¯Û•Ù† Ø¨Û† Ø¦Û•ÙˆÛ•ÛŒ Ø¨Ø²Ø§Ù†Ù† Ú©Û Ú¯ÙˆÙ…Ø§Ù†Ø§ÙˆÛŒÛŒÛ•. Ø¦Û•Ùˆ ÛŒØ§Ø±ÛŒØ²Ø§Ù†Û•ÛŒ Ø²Û†Ø±ØªØ±ÛŒÙ† Ø¯Û•Ù†Ú¯ Ø¨Û•Ø¯Û•Ø³Øª Ø¯Û•Ù‡ÛÙ†ÛØª Ø¦Ø§Ø´Ú©Ø±Ø§ Ø¯Û•Ú©Ø±ÛØª.<br><br><strong>Ú†Û†Ù† Ø¯Û•ÛŒØ¨Û•ÛŒØªÛ•ÙˆÛ• ğŸ† :</strong><br><br>â€¢ <strong>Ù‡Ø§ÙˆÚµØ§ØªÛŒÛŒÛ•Ú©Ø§Ù†:</strong><br>-Ø¦Û•Ú¯Û•Ø± Ù¾ÛØ´ Ú©Û†ØªØ§ÛŒÛŒ Ù‡Ø§ØªÙ†ÛŒ Ú©Ø§Øª ÙÛÙ„Ø¨Ø§Ø²Û•Ú©Û• Ø¨Ø¯Û†Ø²Ù†Û•ÙˆÛ•.<br><br>â€¢ <strong>ÙÛÚµØ¨Ø§Ø²:</strong><br>-Ø¦Û•Ú¯Û•Ø± Ù‡Ø§ÙˆÚµØ§ØªÛŒÛŒÛ•Ú©Ø§Ù† Ù†Û•ÛŒØ§Ù†Ø¯Û†Ø²Ù†Û•ÙˆÛ• Ú©Û• Ú©Û ÙÛÚµØ¨Ø§Ø²Û•.<br>-Ø¦Û•Ú¯Û•Ø± Ú©Ø§ØªÛ•Ú©Û• Ú©Û†ØªØ§ÛŒÛŒ Ø¨ÛØª.`,
                room: "Ú˜ÙˆÙˆØ±", playWithFriends: "ÛŒØ§Ø±ÛŒ Ù„Û•Ú¯Û•Úµ Ù‡Ø§ÙˆÚ•ÛÛŒØ§Ù†", createRoom: "Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ø¯Ù†ÛŒ Ú˜ÙˆÙˆØ±", joinRoom: "Ú†ÙˆÙˆÙ†Û• Ú˜ÙˆÙˆØ±Û•ÙˆÛ•", roomCode: "Ú©Û†Ø¯ÛŒ Ú˜ÙˆÙˆØ±:", enterCode: "Ú©Û†Ø¯ÛŒ Ú˜ÙˆÙˆØ± Ø¨Ù†ÙˆÙˆØ³Û•", creator: "Ø¯Ø±ÙˆØ³ØªÚ©Û•Ø±", myStatus: "Ø¯Û†Ø®ÛŒ Ù…Ù†:", waitingForName: "Ú†Ø§ÙˆÛ•Ú•ÛÛŒ Ù†ÙˆÙˆØ³ÛŒÙ†ÛŒ Ù†Ø§Ùˆ", waitingForOthers: "Ú†Ø§ÙˆÛ•Ú•ÛÛŒ ÛŒØ§Ø±ÛŒØ²Ø§Ù†Ø§Ù†ÛŒ ØªØ±", ready: "Ø¦Ø§Ù…Ø§Ø¯Û•", submit: "Ù¾Ø´ØªÚ•Ø§Ø³ØªÚ©Ø±Ø¯Ù†Û•ÙˆÛ•", notEnoughPlayersPopup: "Ú˜Ù…Ø§Ø±Û•ÛŒ ÛŒØ§Ø±ÛŒØ²Ø§Ù†Ø§Ù† Ú©Û•Ù…Û•. Ù„Ø§Ù†ÛŒ Ú©Û•Ù… 3 ÛŒØ§Ø±ÛŒØ²Ø§Ù† Ù¾ÛÙˆÛŒØ³ØªÛ•.", roomFull: "Ú˜ÙˆÙˆØ±Û•Ú©Û• Ù¾Ú•Û•.", roomNotFound: "Ú©Û†Ø¯ÛŒ Ú˜ÙˆÙˆØ±Û•Ú©Û• Ù†Ø§Ø¯Ø±ÙˆØ³ØªÛ•.", roomStart: "Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ø¯Ù†ÛŒ ÛŒØ§Ø±ÛŒ (3+ ÛŒØ§Ø±ÛŒØ²Ø§Ù†)", gameAlreadyStarted: "ÛŒØ§Ø±ÛŒÛŒÛ•Ú©Û• Ø¯Û•Ø³ØªÛŒÙ¾ÛÚ©Ø±Ø¯ÙˆÙˆÛ•...", enterYourName: "Ù†Ø§ÙˆÛŒ Ø®Û†Øª Ø¨Ù†ÙˆÙˆØ³Û•", nameSubmitSuccess: "Ù†Ø§ÙˆÛŒ ØªÛ† Ù†ÙˆÙˆØ³Ø±Ø§. Ú†Ø§ÙˆÛ•Ú•ÛÛŒ Ø¦Û•ÙˆØ§Ù†ÛŒ ØªØ± Ø¨Û•.", gameOverTitle: "Ú©Û†ØªØ§ÛŒÛŒ ÛŒØ§Ø±ÛŒ", playAgain: "Ø¯ÙˆÙˆØ¨Ø§Ø±Û• ÛŒØ§Ø±ÛŒ Ø¨Ú©Û•ÙˆÛ• Ù„Û• Ù‡Û•Ù…Ø§Ù† Ú˜ÙˆÙˆØ±", exitRoom: "Ú†ÙˆÙˆÙ†Û• Ø¯Û•Ø±Û•ÙˆÛ•ÛŒ Ú˜ÙˆÙˆØ±", startOver: "Ø¯Û•Ø³ØªÙ¾ÛÚ©ÛŒ Ø¯ÙˆÙˆØ¨Ø§Ø±Û• (ÙˆØ´Û• Ùˆ Ú•Û†ÚµÛŒ Ù†ÙˆÛ)", backToSetup: "Ú¯Û•Ú•Ø§Ù†Û•ÙˆÛ• Ø¨Û† Ú•ÛÚ©Ø®Ø³ØªÙ†Û•Ú©Ø§Ù†",
                finishTheTimer: "Ú©Û†ØªØ§ÛŒÛŒ Ù‡ÛÙ†Ø§Ù† Ø¨Û• Ú©Ø§Øª" // NEW TRANSLATION
            },
            en: {
                appName: "The Imposter Game", imposter: "Imposter", civilian: "Civilian", playerCount: "Number of Players (3-12):", imposterCount: "Number of Imposters (1-2):", start: "Start Game", playerName: "Player Name", showRole: "View Your Role", yourRole: "Your Role:", theWord: "The Secret Word:", madeBy: "Made By Naseh M. Zebari", turn: "Player Turn", close: "Close", reset: "Start New Game", revealWord: "Reveal Secret Word (For All)", wordWas: "The secret word was:", selectWord: "Please select a secret word!", validationTitle: "Warning", nameRequired: "Please enter all player names.", notEnoughPlayers: "Not enough players. You need at least 3 players.", revealImposters: "Reveal Imposters", impostersWere: "The Imposters were:", justImposter: "You are the Imposter!", imposterHintLabel: "Word:", startDiscussion: "Start Discussion", discussionTime: "Discussion Time:", timesUp: "Time's Up!", imposterWas: "The Imposter was:", shareLink: "Share the game link with your friends!", and: "and", howToPlayTitle: "How to Play: The Imposter Game", howToPlayBody: `The goal is to convince everyone you know the Secret Wordâ€”or find the person who doesn't.<br><br><strong>1. ğŸ¤« Find Your Role</strong><br>â€¢ The phone is passed around for everyone to look at the screen in secret.<br>â€¢ Most Players will see the <strong>Secret Word</strong> (e.g., Sofa).<br>â€¢ One Player will see <strong>"IMPOSTOR."</strong><br><br><strong>2. ğŸ—£ï¸ Give Clues</strong><br>â€¢ Go around the circle. Each player gives <strong>ONE WORD</strong> to describe the Secret Word.<br>â€¢ <strong>If you know the word:</strong> Your clue must be specific enough to prove you know it, but vague enough to confuse the Impostor.<br>â€¢ <strong>If you are the Impostor:</strong> Give a general clue that fits the category (e.g., Furniture) and try to blend in!<br><br><strong>3. ğŸ—³ï¸ Vote</strong><br>â€¢ After 2-3 rounds of clues, the discussion begins. Accuse the player whose clues seemed the most suspicious or generic.<br>â€¢ Everyone votes on who they think the Impostor is. The player with the most votes is revealed.<br><br><strong>How to Win ğŸ† :</strong><br><br>â€¢ <strong>The Civilians:</strong><br>-If they find out who is really the Imposter before the timer finishes.<br><br>â€¢ <strong>The Imposter:</strong><br>-If the Civilians didnâ€™t find out that he is the Imposter.<br>-If the timer finishes.`,
                room: "Room", playWithFriends: "Play with Friends", createRoom: "Create Room", joinRoom: "Join Room", roomCode: "Room Code:", enterCode: "Enter Room Code", creator: "Creator", myStatus: "My Status:", waitingForName: "Waiting to enter name", waitingForOthers: "Waiting for other players", ready: "Ready", submit: "Submit", notEnoughPlayersPopup: "Not enough players. Minimum 3 players required.", roomFull: "The room is full.", roomNotFound: "The room code is invalid.", roomStart: "Start Game (3+ Players)", gameAlreadyStarted: "Game has started...", enterYourName: "Enter Your Name", nameSubmitSuccess: "Name submitted. Waiting for others.", gameOverTitle: "Game Over", playAgain: "Play Again in Same Room", exitRoom: "Exit Room", startOver: "Start Over (New Words and Roles)", backToSetup: "Back to Settings",
                finishTheTimer: "Finish the Timer" // NEW TRANSLATION
            }
        };
        return translations[l][key] || translations['ku'][key];
    };
    
    const formatTime = (seconds) => {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    };

    const showModal = (titleKey, messageKey, isImposterReveal = false, customContent = null, closeCallback = hideModal) => {
        const title = T(titleKey);
        let message = T(messageKey);
        
        if(isImposterReveal) {
             message = messageKey; // Use raw string if it's the imposter list
        }
        
        modalInner.className = 'modal-content ' + (isImposterReveal ? 'imposter-popup' : '');
        modalInner.innerHTML = `
            <button class="modal-close-btn" onclick="${closeCallback.name}()">Ã—</button>
            <h3 class="modal-title">${title}</h3>
            <div class="modal-message">
                ${customContent || message}
            </div>
            ${!isImposterReveal ? `<button class="primary-btn" onclick="${closeCallback.name}()">
                ${T('close')}
            </button>` : `<button class="primary-btn mt-4" onclick="${closeCallback.name}()">
                ${T('close')}
            </button>`}
        `;
        modal.classList.add('show');
    };

    const hideModal = () => {
        modal.classList.remove('show');
    };

    const toggleLanguage = () => {
        lang = lang === 'ku' ? 'en' : 'ku';
        document.body.className = lang === 'ku' ? 'rtl' : 'ltr english-mode';
        document.getElementById('main-title').textContent = T('appName');
        document.getElementById('helpButton').innerHTML = '?';

        // Re-render the current view to apply language changes
        if (isRoomMode) {
            getRoomSnapshot(currentRoomCode).then(renderRoomLobby);
        } else if (gameActive) {
            renderEndGameView(false);
        } else {
            renderSetupView();
        }
    };
    
    // Function to handle link sharing
    const shareGameLink = async () => {
        if (!currentRoomCode && isRoomMode) return; // Only share if in a room or if we have a room code
        
        let url = window.location.href.split('?')[0];
        let shareText = T('shareLink');
        
        if (isRoomMode) {
           url = url + `?room=${currentRoomCode}`;
           shareText = `${T('roomCode')} ${currentRoomCode}. ${T('shareLink')}`;
        }
        
        if (navigator.share) {
            try {
                await navigator.share({
                    title: T('appName'),
                    text: shareText,
                    url: url
                });
            } catch (error) {
                // Fallback to clipboard if share fails
                await navigator.clipboard.writeText(url);
                showModal('roomCode', `${isRoomMode ? currentRoomCode : url}<br><br><strong>${T('shareLink')}</strong>`);
            }
        } else {
            // Fallback for non-sharing browsers
            await navigator.clipboard.writeText(url);
            showModal('roomCode', `${isRoomMode ? currentRoomCode : url}<br><br><strong>${T('shareLink')}</strong>`);
        }
    };

    // Function to show the help/how-to-play modal
    const showHelpModal = () => {
        showModal('howToPlayTitle', 'howToPlayBody', false, T('howToPlayBody'));
    };

    // --- FIREBASE ROOM MANAGEMENT FUNCTIONS (Updated for Online Database) ---

    /** Gets a snapshot of the room data from Firebase (one-time read) */
    const getRoomSnapshot = async (code) => {
        try {
            const snapshot = await database.ref('rooms/' + code).once('value');
            return snapshot.val();
        } catch (error) {
            console.error("Error getting room snapshot:", error);
            return null;
        }
    };

    /** Starts listening for real-time room updates (used by all players) */
    const startRoomPolling = () => {
        if (!currentRoomCode) return;
        
        if (roomRef) roomRef.off('value', pollRoomCallback);

        roomRef = database.ref('rooms/' + currentRoomCode);
        
        roomRef.on('value', pollRoomCallback, (error) => {
            console.error("Firebase listener error:", error);
            if (currentRoomCode) {
                showModal('validationTitle', 'roomNotFound', false, null, resetGame);
            }
        });
    };

    /** Stops the real-time listener */
    const stopRoomPolling = () => {
        if (roomRef) {
            roomRef.off('value', pollRoomCallback);
            roomRef = null;
        }
    };
    
    /** Callback function for the Firebase real-time listener */
    const pollRoomCallback = (snapshot) => {
        const room = snapshot.val();
        
        if (!room) {
            stopRoomPolling();
            if (currentRoomCode) {
                showModal('validationTitle', 'roomNotFound', false, null, resetGame);
            }
            return;
        }
        
        // Skip rendering if an input field is currently focused
        if (isInputFocused) {
           return;
        }

        // Check if the current player is still in the room list
        if (myPlayerId && !room.players.some(p => p.id === myPlayerId)) {
            stopRoomPolling();
            resetGame(); // Force a full reset
            return;
        }
        
        // Update local state variables
        imposterCount = room.imposterCount;
        playerCount = room.players.length;
        
        const myPlayerData = room.players.find(p => p.id === myPlayerId);
        if (myPlayerData) {
             roles = room.players;
             secretWord = room.secretWord;
             imposterHintWord = room.imposterHintWord;
        }


        if (room.gameState === 'playing' && !isGameStartedInRoom) {
            isGameStartedInRoom = true;
            startGame(room);
        } else if (room.gameState === 'ended' && isGameStartedInRoom) {
            renderGameOverModal();
        } else if (room.gameState === 'setup') {
            if (!isGameStartedInRoom) {
               renderRoomLobby(room);
            } else {
                 isGameStartedInRoom = false;
                 roles = [];
                 clearInterval(timerInterval);
                 timerInterval = null;
                 timeLeft = null;
                 renderRoomLobby(room);
            }
        } else if (room.gameState === 'playing' && isGameStartedInRoom) {
            renderEndGameView(true); // Ensures non-creator gets timer sync
        }
    };

    /** Generates a random 4-letter room code (Unchanged) */
    const generateRoomCode = () => {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let code = '';
        for (let i = 0; i < 4; i++) {
            code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return code;
    };

    /** Creator: Create a new room */
    const createRoom = async () => {
        let code = generateRoomCode();
        let existingRoom = await getRoomSnapshot(code);
        while (existingRoom) {
            code = generateRoomCode();
            existingRoom = await getRoomSnapshot(code);
        }
        
        myPlayerId = database.ref().push().key; 
        
        const newRoom = {
            code: code,
            creatorId: myPlayerId,
            imposterCount: 1,
            players: [
                { id: myPlayerId, name: '', isReady: false, role: '', word: '' }
            ],
            gameState: 'setup',
            secretWord: '',
            imposterHintWord: '',
            discussionStartTime: null,
            discussionDuration: 0
        };
        
        roomRef = database.ref('rooms/' + code);
        await roomRef.set(newRoom);
        
        currentRoomCode = code;
        isRoomCreator = true;
        isRoomMode = true;
        
        renderRoomLobby(newRoom);
        startRoomPolling();
    };

    /** Player: Join an existing room */
    const joinRoom = async (code) => {
        code = code.toUpperCase();
        const room = await getRoomSnapshot(code);
        
        if (!room) {
            showModal('validationTitle', 'roomNotFound');
            return;
        }
        if (room.players.length >= 12) {
            showModal('validationTitle', 'roomFull');
            return;
        }
        if (room.gameState !== 'setup') {
            showModal('validationTitle', 'gameAlreadyStarted');
            return;
        }
        
        myPlayerId = database.ref().push().key; 
        const newPlayer = { id: myPlayerId, name: '', isReady: false, role: '', word: '' };
        
        roomRef = database.ref('rooms/' + code);
        room.players.push(newPlayer);
        await roomRef.update({ players: room.players });
        
        currentRoomCode = code;
        isRoomCreator = room.creatorId === myPlayerId; // Should be false here
        isRoomMode = true;
        
        renderRoomLobby(room);
        startRoomPolling();
    };

    /** Both: Submit their name */
    const submitName = async () => {
        const nameInput = document.getElementById('my-name-input');
        const myName = nameInput.value.trim();
        
        if (myName.length < 1) {
            showModal('validationTitle', 'nameRequired');
            return;
        }
        
        isInputFocused = true;
        const room = await getRoomSnapshot(currentRoomCode);
        isInputFocused = false;
        if (!room) return;

        const myPlayerIndex = room.players.findIndex(p => p.id === myPlayerId);
        if (myPlayerIndex !== -1) {
            room.players[myPlayerIndex].name = myName;
            room.players[myPlayerIndex].isReady = true;
            
            await roomRef.update({ players: room.players });
            
            showModal('validationTitle', 'nameSubmitSuccess', false, null, hideModal);
        }
    };
    
    /** Update imposter count in the room */
    const updateRoomSettings = async (imposterValue) => {
        if (!isRoomCreator) return;
        
        let count = parseInt(imposterValue);
        const room = await getRoomSnapshot(currentRoomCode);
        
        if (!room) return;

        if (isNaN(count) || count < 1) count = 1;
        if (count > 2) count = 2;
        if (count >= room.players.length && room.players.length > 1) {
            count = room.players.length - 1;
        }
        if (count < 1 && room.players.length > 0) count = 1;

        if (roomRef) {
            await roomRef.update({ imposterCount: count });
            imposterCount = count;
        }
    };


    /** Creator: Start the game for everyone in the room */
    const startRoomGame = async () => {
        const room = await getRoomSnapshot(currentRoomCode);
        if (!room || room.players.length < 3) {
            renderNotEnoughPlayersModal();
            return;
        }
        
        const readyPlayers = room.players.filter(p => p.isReady && p.name);
        if (readyPlayers.length < room.players.length) {
            showModal('validationTitle', 'nameRequired');
            return;
        }
        
        // 1. Assign roles
        const wordList = getWordList();
        const secretIndex = Math.floor(Math.random() * wordList.length);
        const newSecretWord = wordList[secretIndex];
        const newImposterHintWord = T('justImposter');
        
        const imposterIndices = [];
        while (imposterIndices.length < room.imposterCount) {
            const index = Math.floor(Math.random() * readyPlayers.length);
            if (!imposterIndices.includes(index)) {
                imposterIndices.push(index);
            }
        }
        
        let rolesList = readyPlayers.map((p, i) => {
            const isImposter = imposterIndices.includes(i);
            const role = isImposter ? T('imposter', lang) : T('civilian', lang);
            const wordContent = isImposter ? newImposterHintWord : newSecretWord;
            
            return {
                ...p,
                role: role,
                word: wordContent,
                name: p.name.trim(),
            };
        });

        rolesList = rolesList.sort(() => Math.random() - 0.5);
        
        // 2. Update room state with game data
        room.players = rolesList;
        room.secretWord = newSecretWord;
        room.imposterHintWord = newImposterHintWord;
        room.gameState = 'playing';
        
        // Update local roles for current player
        roles = rolesList;

        // 3. Save to Firebase
        await roomRef.update({
            players: room.players,
            secretWord: room.secretWord,
            imposterHintWord: room.imposterHintWord,
            gameState: room.gameState
        });

        // 4. Start the game locally for the creator (pollRoomCallback handles the rest)
        isGameStartedInRoom = true;
        startGame(room);
    };

    /** Creator: Reset game inside the room (Keep players/names) */
    const resetRoomGame = async () => {
        const room = await getRoomSnapshot(currentRoomCode);
        if (!room) return;
        
        const updates = {
            gameState: 'setup',
            secretWord: '',
            imposterHintWord: '',
            discussionStartTime: null,
            discussionDuration: 0,
            players: room.players.map(p => ({ ...p, isReady: false, role: '', word: '' }))
        };
        
        await roomRef.update(updates);
        
        isGameStartedInRoom = false;
        roles = [];
        clearInterval(timerInterval);
        timerInterval = null;
        timeLeft = null;
        
        hideModal();
    };

    // NEW FUNCTION: Creator finishes the timer instantly
    const finishRoomTimer = async () => {
        if (!isRoomMode || !isRoomCreator) return;
        
        if (roomRef) {
            clearInterval(timerInterval);
            timerInterval = null;
            timeLeft = 0;
            // Setting gameState to 'ended' will trigger pollRoomCallback for all players
            await roomRef.update({ gameState: 'ended' });
            renderGameOverModal();
        }
    };

    /** Both: Exit the room and go back to the setup view */
    const exitRoom = async () => {
        if (!currentRoomCode) {
            resetGame();
            return;
        }
        
        stopRoomPolling();
        
        const room = await getRoomSnapshot(currentRoomCode);
        if (room) {
            const updatedPlayers = room.players.filter(p => p.id !== myPlayerId);
            
            if (updatedPlayers.length === 0) {
                await database.ref('rooms/' + currentRoomCode).remove();
            } else {
                let updates = { players: updatedPlayers };
                if (isRoomCreator && updatedPlayers.length > 0 && room.creatorId === myPlayerId) {
                    updates.creatorId = updatedPlayers[0].id;
                }
                await database.ref('rooms/' + currentRoomCode).update(updates);
            }
        }
        
        currentRoomCode = null;
        isRoomCreator = false;
        isRoomMode = false;
        isGameStartedInRoom = false;
        myPlayerId = null;
        isInputFocused = false; 
        
        hideModal(); 
        resetGame();
    };

    // --- Core Game Logic & UI (with minor updates for Firebase) ---

    // Function to handle the end of the timer (Room & Local)
    const timerFinished = async () => {
        clearInterval(timerInterval);
        timerInterval = null;
        
        if(isRoomMode) {
            if(isRoomCreator) {
                await roomRef.update({ gameState: 'ended' });
                renderGameOverModal();
            }
            // Non-creators handle 'ended' state via pollRoomCallback
        } else {
            document.getElementById('timerDisplay').textContent = T('timesUp');
            const imposterNames = roles
                .filter(r => r.role === T('imposter'))
                .map(r => r.name);
            const imposterList = imposterNames.join(' ' + T('and') + ' ');
            showModal('imposterWas', imposterList, true);
            // revealImposters(true); // Removed from local mode
        }
    }

    const countdown = () => {
        if (timeLeft <= 0) {
            timerFinished();
        } else {
            timeLeft--;
            const timerEl = document.getElementById('timerDisplay');
            if(timerEl) timerEl.textContent = `${T('discussionTime')} ${formatTime(timeLeft)}`;
        }
    }
    
    const startDiscussion = async () => {
        if (timerInterval) return;

        const duration = playerCount * 60;

        if (isRoomMode) {
            if (isRoomCreator) {
                const room = await getRoomSnapshot(currentRoomCode);
                if (room && room.gameState === 'playing') {
                    
                    // Use Firebase ServerValue.TIMESTAMP to ensure everyone starts at the same *database* time
                    await roomRef.update({
                        discussionStartTime: firebase.database.ServerValue.TIMESTAMP,
                        discussionDuration: duration
                    });
                    
                    // Local timer starts for creator
                    timeLeft = duration;
                    timerInterval = setInterval(countdown, 1000); 
                    
                    const startButton = document.getElementById('startDiscussionButton');
                    if(startButton) {
                       startButton.textContent = T('discussionTime');
                       startButton.disabled = true;
                    }
                    const timerEl = document.getElementById('timerDisplay');
                    if(timerEl) timerEl.textContent = `${T('discussionTime')} ${formatTime(timeLeft)}`;
                }
            }
        } else {
            // Local Mode
            timeLeft = duration; 
            const startButton = document.getElementById('startDiscussionButton');
            startButton.textContent = T('discussionTime');
            startButton.disabled = true;
            document.getElementById('timerDisplay').textContent = `${T('discussionTime')} ${formatTime(timeLeft)}`;
            timerInterval = setInterval(countdown, 1000); 
        }
    };
    
    // DELETED: revealImposters function
    // DELETED: revealWord function
    
    const renderEndGameView = (isRoom = false) => {
        // MODIFICATION 1: Deleted 'revealImposters' button, 'revealWord' button and their corresponding divs.
        // MODIFICATION 2: Added 'finishTheTimer' button for the Room Creator.
        
        const container = document.getElementById('game-container');
        
        const initialTime = playerCount * 60;
        const initialTimeFormatted = formatTime(initialTime);
        let displayTime = timerInterval ? `${T('discussionTime')} ${formatTime(timeLeft)}` : `${T('discussionTime')} ${initialTimeFormatted}`;
        
        
        // Logic to sync timer for non-creators
        if (isRoom && roomRef && !isRoomCreator) {
            roomRef.once('value').then(snapshot => {
                const room = snapshot.val();
                const timerEl = document.getElementById('timerDisplay');
                
                if(room && room.discussionStartTime && room.discussionDuration) {
                    const elapsed = Date.now() - room.discussionStartTime;
                    const remaining = room.discussionDuration * 1000 - elapsed;
                    
                    if(remaining > 0) {
                        timeLeft = Math.ceil(remaining / 1000);
                        if (timerEl) timerEl.textContent = `${T('discussionTime')} ${formatTime(timeLeft)}`;
                        if (!timerInterval) {
                             timerInterval = setInterval(countdown, 1000); 
                        }
                    } else {
                         if (timerEl) timerEl.textContent = T('timesUp');
                    }
                } else {
                     if (timerEl) timerEl.textContent = T('waitingForOthers');
                }
            });
            displayTime = T('waitingForOthers'); // Initial display before async update
        }
        
        if (isRoom && !isRoomCreator) {
            const roomData = roles.find(p => p.id === myPlayerId);
             if (roomData && roomData.role) {
                // If a non-creator refreshes or enters late, they see the word immediately
                secretWord = roles.find(p => p.role === T('civilian'))?.word || '';
                imposterHintWord = T('justImposter');
                
                container.innerHTML = `
                    <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
                    <h2 class="text-xl font-bold text-center text-slate-300 mb-6">${T('turn')}</h2>
                    <div class="title-bar mb-6"></div>
                    
                    <div class="player-card">
                        <p class="text-lg text-slate-300 mb-2">${roomData.name}</p>
                        <p class="role-text-simplified ${roomData.role === T('imposter') ? 'word-imposter' : 'word-civilian'}">
                           ${roomData.role === T('imposter') ? T('justImposter') : roomData.word}
                        </p>
                    </div>

                    <p id="timerDisplay" class="text-2xl text-slate-200 text-center mt-6 mb-4">${displayTime}</p>
                    <button id="startDiscussionButton" class="primary-btn mb-6 opacity-50 cursor-not-allowed" 
                            disabled style="background: linear-gradient(145deg, #6366f1, #4f46e5); color: white;">
                        ${T('startDiscussion')}
                    </button>
                    <p class="text-sm text-center text-slate-400">${T('waitingForOthers')}</p>
                    
                    <div class="mt-8">
                        <button class="back-btn mt-2" onclick="exitRoom()">
                            ${T('exitRoom')}
                        </button>
                    </div>
                    <div class="footer-text mt-8">${T('madeBy')} <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a></div>
                `;
                return;
            }
        }
        
        // This is for Local Mode OR the Room Creator End Screen
        container.innerHTML = `
             <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
             <h2 id="timerDisplay" class="text-2xl text-slate-200 text-center mb-6">${displayTime}</h2>
             <div class="title-bar mb-6"></div>

             <button id="startDiscussionButton" class="primary-btn mb-6 ${isRoom && !isRoomCreator ? 'opacity-50 cursor-not-allowed' : ''}" 
                     onclick="startDiscussion()" 
                     ${isRoom && !isRoomCreator ? 'disabled' : ''}
                     style="background: linear-gradient(145deg, #6366f1, #4f46e5); color: white;">
                 ${T('startDiscussion')}
             </button>

             ${isRoom && isRoomCreator ? `
                 <button class="primary-btn secondary-btn mb-4" onclick="finishRoomTimer()" style="background: linear-gradient(145deg, #f87171, #ef4444); color: white;">
                     ${T('finishTheTimer')}
                 </button>
             ` : ''}

             <div class="mt-8">
                 ${isRoom ? `
                    <button class="primary-btn bg-secondary hover:bg-indigo-600 mb-4" onclick="resetRoomGame()" ${!isRoomCreator ? 'disabled' : ''} style="background: linear-gradient(145deg, #facc15, #eab308); color: #1e293b;">
                         ${T('startOver')}
                     </button>
                    <button class="back-btn mt-2" onclick="exitRoom()">
                        ${T('exitRoom')}
                    </button>
                 ` : `
                    <button class="primary-btn bg-secondary hover:bg-indigo-600" onclick="resetGame()" style="background: linear-gradient(145deg, #facc15, #eab308); color: #1e293b;">
                         ${T('reset')}
                     </button>
                 `}
             </div>
           
             <div class="footer-text mt-8">
                 ${T('madeBy')}
                 <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a>
             </div>
         `;
         
         if(timerInterval) {
             const startButton = document.getElementById('startDiscussionButton');
             if(startButton) {
                 startButton.textContent = T('discussionTime');
                 startButton.disabled = true;
             }
         }
    };
    
    const getNamesFromDOM = () => {
         const inputs = document.querySelectorAll('#player-names-input input[type="text"]');
         playerNames = Array.from(inputs).map(input => input.value.trim());
         return playerNames;
    };
    
    const startGame = (roomData = null) => {
        hideModal();
        gameActive = true;
        
        if (roomData) {
            isRoomMode = true;
            roles = roomData.players;
            playerCount = roles.length;
            imposterCount = roomData.imposterCount;
            secretWord = roomData.secretWord;
            imposterHintWord = roomData.imposterHintWord;
            
            const myPlayerIndex = roles.findIndex(p => p.id === myPlayerId);
            renderRoomGameView(myPlayerIndex);
            
        } else {
             // Local Mode Game Setup
            playerNames = getNamesFromDOM().filter(n => n.length > 0);
            playerCount = playerNames.length;
            
            if (playerCount < 3) {
                 renderNotEnoughPlayersModal();
                 gameActive = false;
                 return;
            }
            if (playerNames.some(name => name.length < 1)) {
                 showModal('validationTitle', 'nameRequired');
                 gameActive = false;
                 return;
            }

            const wordList = getWordList();
            const secretIndex = Math.floor(Math.random() * wordList.length);
            secretWord = wordList[secretIndex];
            imposterHintWord = T('justImposter');
            
            const imposterIndices = [];
            while (imposterIndices.length < imposterCount) {
                const index = Math.floor(Math.random() * playerCount);
                if (!imposterIndices.includes(index)) {
                    imposterIndices.push(index);
                }
            }
            
            roles = playerNames.map((name, i) => {
                const isImposter = imposterIndices.includes(i);
                return {
                    name: name,
                    role: isImposter ? T('imposter', lang) : T('civilian', lang),
                    word: isImposter ? imposterHintWord : secretWord
                };
            }).sort(() => Math.random() - 0.5);

            renderPlayerTurnView(0);
        }
    };

    const showRole = (playerIndex) => {
        const roleData = isRoomMode ? roles.find(p => p.id === myPlayerId) : roles[playerIndex];
        
        if (!roleData) return;
        
        // --- UPDATED ROLE DISPLAY ---
        const isImposter = roleData.role === T('imposter');
        const roleContent = isImposter 
            ? `<p class="role-text-simplified word-imposter">${T('justImposter')}</p>`
            : `<p class="role-text-simplified word-civilian">${roleData.word}</p>`;

        const container = isRoomMode ? document.getElementById('room-player-turn') : document.getElementById('player-turn-view');
        
        container.innerHTML = `
            <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
            <h2 class="text-xl font-bold text-center text-slate-300 mb-6">${T('yourRole')}</h2>
            <div class="title-bar mb-6"></div>

            <div class="player-card">
                <p class="text-lg text-slate-300 mb-2">${roleData.name}</p>
                ${roleContent}
            </div>
            
            <button class="primary-btn mt-6" onclick="hideRole(${playerIndex})">
                ${T('close')}
            </button>
        `;
    };

    const hideRole = (playerIndex) => {
        if (isRoomMode) {
            renderEndGameView(true); // Go directly to the Discussion screen in room mode
        } else if (playerIndex < roles.length - 1) {
            renderPlayerTurnView(playerIndex + 1);
        } else {
            renderEndGameView(false);
        }
    };
    
    const renderPlayerTurnView = (playerIndex = 0) => {
        // MODIFICATION 3: REMOVED: shareButton.classList.add('hidden');
        const container = document.getElementById('game-container');
        const currentPlayer = roles[playerIndex];
        const totalPlayers = roles.length;

        container.innerHTML = `
            <div id="player-turn-view">
                <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
                <h2 class="text-xl font-bold text-center text-slate-300 mb-6">${T('turn')} ${playerIndex + 1}/${totalPlayers}</h2>
                <div class="title-bar mb-6"></div>

                <div class="player-card">
                    <p class="text-lg text-slate-300 mb-2">${T('playerName')}:</p>
                    <p class="text-3xl font-bold text-primary">${currentPlayer.name}</p>
                </div>

                <button class="primary-btn mt-6" onclick="showRole(${playerIndex})">
                    ${T('showRole')}
                </button>
                
                <button class="back-btn" onclick="resetGame()">
                    ${T('backToSetup')}
                </button>
                 <div class="footer-text mt-8">${T('madeBy')} <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a></div>
            </div>
        `;
    };
    
    const renderRoomGameView = (myPlayerIndex) => {
        // MODIFICATION 4: REMOVED: shareButton.classList.add('hidden');
        const container = document.getElementById('game-container');
        const myPlayerData = roles.find(p => p.id === myPlayerId);
        
        if (!myPlayerData) return; // Should not happen in a valid game state

        container.innerHTML = `
            <div id="room-player-turn">
                <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
                <h2 class="text-xl font-bold text-center text-slate-300 mb-6">${T('turn')}</h2>
                <div class="title-bar mb-6"></div>

                <div class="player-card">
                    <p class="text-lg text-slate-300 mb-2">${T('playerName')}:</p>
                    <p class="text-3xl font-bold text-primary">${myPlayerData.name}</p>
                </div>

                <button class="primary-btn mt-6" onclick="showRole(${myPlayerIndex})">
                    ${T('showRole')}
                </button>
                
                <button class="back-btn" onclick="exitRoom()">
                    ${T('exitRoom')}
                </button>
                 <div class="footer-text mt-8">${T('madeBy')} <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a></div>
            </div>
        `;
    };
    
    const renderGameOverModal = () => {
         // This runs when pollRoomCallback detects gameState === 'ended'
        const imposterNames = roles
            .filter(r => r.role === T('imposter'))
            .map(r => r.name);
        const imposterList = imposterNames.join(' ' + T('and') + ' ');
        
        const message = `
            <div class="text-right ${lang === 'en' ? 'text-left' : ''}">
                <p class="text-lg text-slate-300 mb-2">${T('wordWas')}</p>
                <p class="text-2xl font-bold text-primary mb-4">${secretWord}</p>
                <p class="text-lg text-slate-300 mb-2">${T('impostersWere')}</p>
                <p class="text-2xl font-bold word-imposter">${imposterList}</p>
            </div>
            <button class="primary-btn mt-6 mb-2" onclick="${isRoomCreator ? 'resetRoomGame()' : 'hideModal()'}">
                ${isRoomCreator ? T('playAgain') : T('close')}
            </button>
            <button class="back-btn mt-2" onclick="exitRoom()">
                ${T('exitRoom')}
            </button>
        `;

        showModal('gameOverTitle', '', true, message, hideModal);
    };

    const renderNotEnoughPlayersModal = () => {
        showModal('validationTitle', 'notEnoughPlayersPopup');
    };

    const renderSetupView = () => {
        isRoomMode = false;
        gameActive = false;
        // MODIFICATION 5: REMOVED: shareButton.classList.add('hidden');
        helpButton.classList.remove('hidden');

        const container = document.getElementById('game-container');
        
        // Ensure playerNames array matches current playerCount
        if (playerNames.length !== playerCount) {
             playerNames = Array(playerCount).fill('').map((_, i) => playerNames[i] || '');
        }

        const nameInputs = playerNames.map((name, index) => `
            <input type="text" placeholder="${T('playerName')} ${index + 1}" value="${name}" 
                   onfocus="isInputFocused = true" 
                   onblur="isInputFocused = false" 
                   onchange="getNamesFromDOM()">
        `).join('');

        container.innerHTML = `
            <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
            <div class="title-bar mb-6"></div>
            
            <button class="lang-btn" onclick="toggleLanguage()">
                ${lang === 'ku' ? 'English Mode' : 'Ú©ÙˆØ±Ø¯ÛŒ'}
            </button>
            
            <p class="text-slate-300 mb-2 text-right ${lang === 'en' ? 'text-left' : ''}">${T('playerCount')}</p>
            <input type="number" min="3" max="12" value="${playerCount}" onchange="handlePlayerCountChange(event)" class="mb-4">

            <p class="text-slate-300 mb-2 text-right ${lang === 'en' ? 'text-left' : ''}">${T('imposterCount')}</p>
            <input type="number" min="1" max="2" value="${imposterCount}" onchange="handleImposterCountChange(event)" class="mb-6">

            <div id="player-names-input">
                <p class="text-slate-300 mb-2 text-right ${lang === 'en' ? 'text-left' : ''}">${T('playerName')} ${T('and')} ${T('playerName')}:</p>
                ${nameInputs}
            </div>

            <button class="primary-btn mt-6" onclick="startGame()">
                ${T('start')}
            </button>
            
            <button class="secondary-btn" onclick="renderRoomMenu()">
                ${T('playWithFriends')}
            </button>
            
            <div class="footer-text">
                ${T('madeBy')}
                <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a>
            </div>
        `;
    };
    
    const handlePlayerCountChange = (event) => {
         let count = parseInt(event.target.value);
         if (isNaN(count) || count < 3) count = 3;
         if (count > 12) count = 12;
         playerCount = count;
         if (imposterCount >= count) {
             imposterCount = count > 1 ? 1 : 1;
         }
         
         // Update playerNames array when count changes
         if (playerNames.length > playerCount) {
             playerNames = playerNames.slice(0, playerCount);
         } else if (playerNames.length < playerCount) {
             for (let i = playerNames.length; i < playerCount; i++) {
                 playerNames.push('');
             }
         }
         renderSetupView();
     };

     const handleImposterCountChange = (event) => {
         let count = parseInt(event.target.value);
         if (isNaN(count) || count < 1) count = 1;
         if (count > 2 || count >= playerCount) count = Math.min(2, playerCount - 1);
         imposterCount = count;
         renderSetupView();
     };

    const renderRoomMenu = () => {
        // MODIFICATION 6: REMOVED: shareButton.classList.add('hidden');
        const container = document.getElementById('game-container');
        container.innerHTML = `
            <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
            <div class="title-bar mb-6"></div>
            
            <button class="secondary-btn mb-4" onclick="createRoom()">
                ${T('createRoom')}
            </button>
            
            <p class="text-slate-300 mb-2 text-right ${lang === 'en' ? 'text-left' : ''}">${T('enterCode')}</p>
            <input type="text" id="join-code-input" placeholder="ABCD" maxlength="4" class="mb-4 english-mode" onfocus="isInputFocused = true" onblur="isInputFocused = false">
            
            <button class="primary-btn" onclick="joinRoom(document.getElementById('join-code-input').value)">
                ${T('joinRoom')}
            </button>
            
            <button class="back-btn" onclick="renderSetupView()">
                ${T('backToSetup')}
            </button>
            
            <div class="footer-text mt-8">
                ${T('madeBy')}
                <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a>
            </div>
        `;
    };
    
    const copyRoomCode = async () => {
        if (currentRoomCode) {
            await navigator.clipboard.writeText(currentRoomCode);
            showModal('roomCode', `${currentRoomCode}<br><br><strong>${T('shareLink')}</strong>`);
        }
     };

    const renderRoomLobby = (room) => {
        currentRoomCode = room.code;
        isRoomCreator = room.creatorId === myPlayerId;
        
        // Find current player's name
        const myPlayerData = room.players.find(p => p.id === myPlayerId) || { name: '', isReady: false };
        const myPlayerName = myPlayerData.name;
        const myStatusKey = myPlayerData.name ? (myPlayerData.isReady ? 'ready' : 'waitingForOthers') : 'waitingForName';
        
        const container = document.getElementById('game-container');
        
        // Show share button only in lobby (This line is now redundant but kept for original intent consistency)
        shareButton.classList.remove('hidden');

        const playerListHTML = room.players.map(p => {
            const isCreator = p.id === room.creatorId;
            const statusText = p.isReady ? T('ready') : T('waitingForName');
            const statusClass = p.isReady ? 'ready' : '';
            return `
                <div class="lobby-player-item ${isCreator ? 'creator' : ''}">
                    <span class="font-bold">${p.name || T('waitingForName')} ${isCreator ? `(${T('creator')})` : ''}</span>
                    <span class="status ${statusClass}">${statusText}</span>
                </div>
            `;
        }).join('');

        const isMinimumPlayers = room.players.length >= 3;
        const allPlayersReady = room.players.every(p => p.isReady && p.name);

        container.innerHTML = `
            <h1 class="text-3xl font-bold text-center text-primary mb-4">${T('appName')}</h1>
            <div class="title-bar mb-6"></div>
            
            <p id="room-code-label">${T('roomCode')}</p>
            <p id="room-code-display" onclick="copyRoomCode()">${room.code}</p>
            <p class="text-sm text-slate-400 text-center mb-6">${T('shareLink')}</p>
            
            <div class="flex justify-between items-center text-slate-300 mb-4 ${lang === 'en' ? 'flex-row-reverse' : ''}">
                <p><strong>${T('myStatus')}</strong></p>
                <p class="status ${myStatusKey === 'ready' ? 'ready' : ''}">${T(myStatusKey)}</p>
            </div>
            
            <p class="text-slate-300 mb-2 text-right ${lang === 'en' ? 'text-left' : ''}">${T('enterYourName')}</p>
            <div class="flex gap-2">
                <input type="text" id="my-name-input" placeholder="${T('playerName')}" value="${myPlayerName}" 
                       onfocus="isInputFocused = true" 
                       onblur="isInputFocused = false" 
                       class="flex-grow">
                <button class="primary-btn w-auto px-6 py-2" onclick="submitName()">
                    ${T('submit')}
                </button>
            </div>

            ${isRoomCreator ? `
                <div class="mt-4">
                    <p class="text-slate-300 mb-2 text-right ${lang === 'en' ? 'text-left' : ''}">${T('imposterCount')}</p>
                    <input type="number" min="1" max="2" value="${room.imposterCount}" 
                           onchange="updateRoomSettings(this.value)" class="mb-4">
                </div>
            ` : `<p class="text-slate-400 text-sm mt-4 text-center">${T('imposterCount')}: ${room.imposterCount}</p>`}

            <div class="mt-6 mb-4 max-h-40 overflow-y-auto pr-1">
                ${playerListHTML}
            </div>

            <button class="primary-btn mt-4 ${!isMinimumPlayers || !allPlayersReady || !isRoomCreator ? 'opacity-50 cursor-not-allowed' : ''}" 
                    onclick="startRoomGame()" ${!isMinimumPlayers || !allPlayersReady || !isRoomCreator ? 'disabled' : ''}>
                ${T('roomStart')}
            </button>
            
            <button class="back-btn" onclick="exitRoom()">
                ${T('exitRoom')}
            </button>
            
            <div class="footer-text mt-8">
                ${T('madeBy')}
                <a href="https://www.instagram.com/n4.5e7/" target="_blank" class="hover:text-primary">@n4.5e7</a>
            </div>
        `;
    };
    
    const resetGame = (skipRoomCheck = false) => {
        if (isRoomMode && isRoomCreator && !skipRoomCheck) {
            resetRoomGame();
            return;
        }
        
        gameActive = false;
        roles = [];
        secretWord = '';
        imposterHintWord = '';
        clearInterval(timerInterval);
        timerInterval = null;
        timeLeft = null;
        
        if (!isRoomMode || skipRoomCheck) {
            stopRoomPolling();
            currentRoomCode = null;
            isRoomCreator = false;
            isRoomMode = false;
            isGameStartedInRoom = false;
            myPlayerId = null;
        }
        
        // Reset player names array to default length for local mode
        playerNames = Array(playerCount).fill('').map((_, i) => playerNames[i] || '');
        
        renderSetupView();
    };

    // --- Event Handlers & Initialization ---
    
    // Check for room code in URL on load
    const checkUrlForRoom = () => {
         const urlParams = new URLSearchParams(window.location.search);
         const roomCode = urlParams.get('room');
         if (roomCode && roomCode.length === 4) {
             joinRoom(roomCode);
             window.history.replaceState({}, document.title, window.location.pathname); // Clean up URL
         }
    };
    
    // Window onload initializes Firebase
    window.onload = () => {
        // Initialize Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        database = firebase.database();

         if (playerNames.length === 0) {
             for (let i = 0; i < playerCount; i++) {
                playerNames.push('');
            }
        }
        renderSetupView();
        checkUrlForRoom(); // Check if a user clicked a share link
    };
 </script>
</body>
</html>
 